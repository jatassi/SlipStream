// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: download_mappings.sql

package sqlc

import (
	"context"
	"database/sql"
)

const clearDownloadMappingSlot = `-- name: ClearDownloadMappingSlot :exec
UPDATE download_mappings SET target_slot_id = NULL
WHERE client_id = ? AND download_id = ?
`

type ClearDownloadMappingSlotParams struct {
	ClientID   int64  `json:"client_id"`
	DownloadID string `json:"download_id"`
}

// Req 10.2.1: Clear slot when download fails or is rejected
func (q *Queries) ClearDownloadMappingSlot(ctx context.Context, arg ClearDownloadMappingSlotParams) error {
	_, err := q.db.ExecContext(ctx, clearDownloadMappingSlot, arg.ClientID, arg.DownloadID)
	return err
}

const createDownloadMapping = `-- name: CreateDownloadMapping :one
INSERT INTO download_mappings (
    client_id, download_id, movie_id, series_id, season_number,
    episode_id, is_season_pack, is_complete_series, target_slot_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT (client_id, download_id) DO UPDATE SET
    movie_id = excluded.movie_id,
    series_id = excluded.series_id,
    season_number = excluded.season_number,
    episode_id = excluded.episode_id,
    is_season_pack = excluded.is_season_pack,
    is_complete_series = excluded.is_complete_series,
    target_slot_id = excluded.target_slot_id
RETURNING id, client_id, download_id, movie_id, series_id, season_number, episode_id, is_season_pack, is_complete_series, created_at, target_slot_id
`

type CreateDownloadMappingParams struct {
	ClientID         int64         `json:"client_id"`
	DownloadID       string        `json:"download_id"`
	MovieID          sql.NullInt64 `json:"movie_id"`
	SeriesID         sql.NullInt64 `json:"series_id"`
	SeasonNumber     sql.NullInt64 `json:"season_number"`
	EpisodeID        sql.NullInt64 `json:"episode_id"`
	IsSeasonPack     int64         `json:"is_season_pack"`
	IsCompleteSeries int64         `json:"is_complete_series"`
	TargetSlotID     sql.NullInt64 `json:"target_slot_id"`
}

func (q *Queries) CreateDownloadMapping(ctx context.Context, arg CreateDownloadMappingParams) (*DownloadMapping, error) {
	row := q.db.QueryRowContext(ctx, createDownloadMapping,
		arg.ClientID,
		arg.DownloadID,
		arg.MovieID,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeID,
		arg.IsSeasonPack,
		arg.IsCompleteSeries,
		arg.TargetSlotID,
	)
	var i DownloadMapping
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.DownloadID,
		&i.MovieID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeID,
		&i.IsSeasonPack,
		&i.IsCompleteSeries,
		&i.CreatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const deleteDownloadMapping = `-- name: DeleteDownloadMapping :exec
DELETE FROM download_mappings
WHERE client_id = ? AND download_id = ?
`

type DeleteDownloadMappingParams struct {
	ClientID   int64  `json:"client_id"`
	DownloadID string `json:"download_id"`
}

func (q *Queries) DeleteDownloadMapping(ctx context.Context, arg DeleteDownloadMappingParams) error {
	_, err := q.db.ExecContext(ctx, deleteDownloadMapping, arg.ClientID, arg.DownloadID)
	return err
}

const deleteDownloadMappingsByMovieID = `-- name: DeleteDownloadMappingsByMovieID :exec
DELETE FROM download_mappings WHERE movie_id = ?
`

// Clean up download mappings when a movie is deleted
func (q *Queries) DeleteDownloadMappingsByMovieID(ctx context.Context, movieID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteDownloadMappingsByMovieID, movieID)
	return err
}

const deleteDownloadMappingsBySeriesID = `-- name: DeleteDownloadMappingsBySeriesID :exec
DELETE FROM download_mappings WHERE series_id = ?
`

// Clean up download mappings when a series is deleted
func (q *Queries) DeleteDownloadMappingsBySeriesID(ctx context.Context, seriesID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteDownloadMappingsBySeriesID, seriesID)
	return err
}

const deleteOldDownloadMappings = `-- name: DeleteOldDownloadMappings :exec
DELETE FROM download_mappings
WHERE created_at < datetime('now', '-7 days')
`

func (q *Queries) DeleteOldDownloadMappings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldDownloadMappings)
	return err
}

const getDownloadMapping = `-- name: GetDownloadMapping :one
SELECT id, client_id, download_id, movie_id, series_id, season_number, episode_id, is_season_pack, is_complete_series, created_at, target_slot_id FROM download_mappings
WHERE client_id = ? AND download_id = ?
`

type GetDownloadMappingParams struct {
	ClientID   int64  `json:"client_id"`
	DownloadID string `json:"download_id"`
}

func (q *Queries) GetDownloadMapping(ctx context.Context, arg GetDownloadMappingParams) (*DownloadMapping, error) {
	row := q.db.QueryRowContext(ctx, getDownloadMapping, arg.ClientID, arg.DownloadID)
	var i DownloadMapping
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.DownloadID,
		&i.MovieID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeID,
		&i.IsSeasonPack,
		&i.IsCompleteSeries,
		&i.CreatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const getDownloadMappingsByClientDownloadIDs = `-- name: GetDownloadMappingsByClientDownloadIDs :many
SELECT id, client_id, download_id, movie_id, series_id, season_number, episode_id, is_season_pack, is_complete_series, created_at, target_slot_id FROM download_mappings
WHERE (client_id, download_id) IN (/*SLICE:client_download_ids*//*SLICE:client_download_ids*/?)
`

func (q *Queries) GetDownloadMappingsByClientDownloadIDs(ctx context.Context) ([]*DownloadMapping, error) {
	rows, err := q.db.QueryContext(ctx, getDownloadMappingsByClientDownloadIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DownloadMapping{}
	for rows.Next() {
		var i DownloadMapping
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.DownloadID,
			&i.MovieID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeID,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
			&i.CreatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDownloadMappingsBySlot = `-- name: GetDownloadMappingsBySlot :many
SELECT id, client_id, download_id, movie_id, series_id, season_number, episode_id, is_season_pack, is_complete_series, created_at, target_slot_id FROM download_mappings
WHERE target_slot_id = ?
ORDER BY created_at DESC
`

// Get all mappings targeting a specific slot
func (q *Queries) GetDownloadMappingsBySlot(ctx context.Context, targetSlotID sql.NullInt64) ([]*DownloadMapping, error) {
	rows, err := q.db.QueryContext(ctx, getDownloadMappingsBySlot, targetSlotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DownloadMapping{}
	for rows.Next() {
		var i DownloadMapping
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.DownloadID,
			&i.MovieID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeID,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
			&i.CreatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDownloadingMovieIDs = `-- name: GetDownloadingMovieIDs :many
SELECT DISTINCT movie_id FROM download_mappings
WHERE movie_id IS NOT NULL
`

func (q *Queries) GetDownloadingMovieIDs(ctx context.Context) ([]sql.NullInt64, error) {
	rows, err := q.db.QueryContext(ctx, getDownloadingMovieIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullInt64{}
	for rows.Next() {
		var movie_id sql.NullInt64
		if err := rows.Scan(&movie_id); err != nil {
			return nil, err
		}
		items = append(items, movie_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDownloadingSeriesData = `-- name: GetDownloadingSeriesData :many
SELECT DISTINCT series_id, season_number, episode_id, is_season_pack, is_complete_series
FROM download_mappings
WHERE series_id IS NOT NULL
`

type GetDownloadingSeriesDataRow struct {
	SeriesID         sql.NullInt64 `json:"series_id"`
	SeasonNumber     sql.NullInt64 `json:"season_number"`
	EpisodeID        sql.NullInt64 `json:"episode_id"`
	IsSeasonPack     int64         `json:"is_season_pack"`
	IsCompleteSeries int64         `json:"is_complete_series"`
}

func (q *Queries) GetDownloadingSeriesData(ctx context.Context) ([]*GetDownloadingSeriesDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getDownloadingSeriesData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDownloadingSeriesDataRow{}
	for rows.Next() {
		var i GetDownloadingSeriesDataRow
		if err := rows.Scan(
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeID,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isEpisodeDownloading = `-- name: IsEpisodeDownloading :one
SELECT EXISTS(
    SELECT 1 FROM download_mappings
    WHERE episode_id = ?
       OR (series_id = ? AND season_number = ? AND (is_season_pack = 1 OR is_complete_series = 1))
       OR (series_id = ? AND is_complete_series = 1)
) AS downloading
`

type IsEpisodeDownloadingParams struct {
	EpisodeID    sql.NullInt64 `json:"episode_id"`
	SeriesID     sql.NullInt64 `json:"series_id"`
	SeasonNumber sql.NullInt64 `json:"season_number"`
	SeriesID_2   sql.NullInt64 `json:"series_id_2"`
}

func (q *Queries) IsEpisodeDownloading(ctx context.Context, arg IsEpisodeDownloadingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEpisodeDownloading,
		arg.EpisodeID,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.SeriesID_2,
	)
	var downloading int64
	err := row.Scan(&downloading)
	return downloading, err
}

const isMovieDownloading = `-- name: IsMovieDownloading :one
SELECT EXISTS(
    SELECT 1 FROM download_mappings WHERE movie_id = ?
) AS downloading
`

func (q *Queries) IsMovieDownloading(ctx context.Context, movieID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isMovieDownloading, movieID)
	var downloading int64
	err := row.Scan(&downloading)
	return downloading, err
}

const isSeasonDownloading = `-- name: IsSeasonDownloading :one
SELECT EXISTS(
    SELECT 1 FROM download_mappings
    WHERE series_id = ? AND season_number = ? AND (is_season_pack = 1 OR is_complete_series = 1)
) AS downloading
`

type IsSeasonDownloadingParams struct {
	SeriesID     sql.NullInt64 `json:"series_id"`
	SeasonNumber sql.NullInt64 `json:"season_number"`
}

func (q *Queries) IsSeasonDownloading(ctx context.Context, arg IsSeasonDownloadingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isSeasonDownloading, arg.SeriesID, arg.SeasonNumber)
	var downloading int64
	err := row.Scan(&downloading)
	return downloading, err
}

const isSeriesDownloading = `-- name: IsSeriesDownloading :one
SELECT EXISTS(
    SELECT 1 FROM download_mappings WHERE series_id = ? AND is_complete_series = 1
) AS downloading
`

func (q *Queries) IsSeriesDownloading(ctx context.Context, seriesID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isSeriesDownloading, seriesID)
	var downloading int64
	err := row.Scan(&downloading)
	return downloading, err
}

const listActiveDownloadMappings = `-- name: ListActiveDownloadMappings :many
SELECT id, client_id, download_id, movie_id, series_id, season_number, episode_id, is_season_pack, is_complete_series, created_at, target_slot_id FROM download_mappings
ORDER BY created_at DESC
`

func (q *Queries) ListActiveDownloadMappings(ctx context.Context) ([]*DownloadMapping, error) {
	rows, err := q.db.QueryContext(ctx, listActiveDownloadMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DownloadMapping{}
	for rows.Next() {
		var i DownloadMapping
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.DownloadID,
			&i.MovieID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeID,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
			&i.CreatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
