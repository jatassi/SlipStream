// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: plex_refresh_queue.sql

package sqlc

import (
	"context"
	"database/sql"
)

const clearPlexRefreshes = `-- name: ClearPlexRefreshes :exec
DELETE FROM plex_refresh_queue
WHERE notification_id = ? AND server_id = ?
`

type ClearPlexRefreshesParams struct {
	NotificationID int64  `json:"notification_id"`
	ServerID       string `json:"server_id"`
}

// Clear all pending refresh items for a notification and server
func (q *Queries) ClearPlexRefreshes(ctx context.Context, arg ClearPlexRefreshesParams) error {
	_, err := q.db.ExecContext(ctx, clearPlexRefreshes, arg.NotificationID, arg.ServerID)
	return err
}

const clearPlexRefreshesBySection = `-- name: ClearPlexRefreshesBySection :exec
DELETE FROM plex_refresh_queue
WHERE notification_id = ? AND server_id = ? AND section_key = ?
`

type ClearPlexRefreshesBySectionParams struct {
	NotificationID int64  `json:"notification_id"`
	ServerID       string `json:"server_id"`
	SectionKey     int64  `json:"section_key"`
}

// Clear pending refresh items for a specific section
func (q *Queries) ClearPlexRefreshesBySection(ctx context.Context, arg ClearPlexRefreshesBySectionParams) error {
	_, err := q.db.ExecContext(ctx, clearPlexRefreshesBySection, arg.NotificationID, arg.ServerID, arg.SectionKey)
	return err
}

const countPendingPlexRefreshesPerSection = `-- name: CountPendingPlexRefreshesPerSection :many
SELECT notification_id, server_id, section_key, COUNT(*) as count
FROM plex_refresh_queue
GROUP BY notification_id, server_id, section_key
`

type CountPendingPlexRefreshesPerSectionRow struct {
	NotificationID int64  `json:"notification_id"`
	ServerID       string `json:"server_id"`
	SectionKey     int64  `json:"section_key"`
	Count          int64  `json:"count"`
}

// Count pending refreshes per section (for deciding full vs partial refresh)
func (q *Queries) CountPendingPlexRefreshesPerSection(ctx context.Context) ([]*CountPendingPlexRefreshesPerSectionRow, error) {
	rows, err := q.db.QueryContext(ctx, countPendingPlexRefreshesPerSection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CountPendingPlexRefreshesPerSectionRow{}
	for rows.Next() {
		var i CountPendingPlexRefreshesPerSectionRow
		if err := rows.Scan(
			&i.NotificationID,
			&i.ServerID,
			&i.SectionKey,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deletePlexRefreshByID = `-- name: DeletePlexRefreshByID :exec
DELETE FROM plex_refresh_queue WHERE id = ?
`

// Delete a specific queue item by ID
func (q *Queries) DeletePlexRefreshByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePlexRefreshByID, id)
	return err
}

const deletePlexRefreshesForNotification = `-- name: DeletePlexRefreshesForNotification :exec
DELETE FROM plex_refresh_queue WHERE notification_id = ?
`

// Delete all queue items for a notification (used when notification is deleted)
func (q *Queries) DeletePlexRefreshesForNotification(ctx context.Context, notificationID int64) error {
	_, err := q.db.ExecContext(ctx, deletePlexRefreshesForNotification, notificationID)
	return err
}

const enqueuePlexRefresh = `-- name: EnqueuePlexRefresh :one
INSERT OR REPLACE INTO plex_refresh_queue (notification_id, server_id, section_key, path, queued_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id, notification_id, server_id, section_key, path, queued_at
`

type EnqueuePlexRefreshParams struct {
	NotificationID int64          `json:"notification_id"`
	ServerID       string         `json:"server_id"`
	SectionKey     int64          `json:"section_key"`
	Path           sql.NullString `json:"path"`
}

// Enqueue a path for Plex library refresh, using INSERT OR REPLACE for deduplication
func (q *Queries) EnqueuePlexRefresh(ctx context.Context, arg EnqueuePlexRefreshParams) (*PlexRefreshQueue, error) {
	row := q.db.QueryRowContext(ctx, enqueuePlexRefresh,
		arg.NotificationID,
		arg.ServerID,
		arg.SectionKey,
		arg.Path,
	)
	var i PlexRefreshQueue
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.ServerID,
		&i.SectionKey,
		&i.Path,
		&i.QueuedAt,
	)
	return &i, err
}

const getAllPendingPlexRefreshes = `-- name: GetAllPendingPlexRefreshes :many
SELECT id, notification_id, server_id, section_key, path, queued_at FROM plex_refresh_queue
ORDER BY notification_id, server_id, section_key, queued_at
`

// Get all pending refresh items grouped for scheduler processing
func (q *Queries) GetAllPendingPlexRefreshes(ctx context.Context) ([]*PlexRefreshQueue, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingPlexRefreshes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PlexRefreshQueue{}
	for rows.Next() {
		var i PlexRefreshQueue
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.ServerID,
			&i.SectionKey,
			&i.Path,
			&i.QueuedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPlexRefreshes = `-- name: GetPendingPlexRefreshes :many
SELECT id, notification_id, server_id, section_key, path, queued_at FROM plex_refresh_queue
WHERE notification_id = ? AND server_id = ?
ORDER BY queued_at
`

type GetPendingPlexRefreshesParams struct {
	NotificationID int64  `json:"notification_id"`
	ServerID       string `json:"server_id"`
}

// Get all pending refresh items for a specific notification and server
func (q *Queries) GetPendingPlexRefreshes(ctx context.Context, arg GetPendingPlexRefreshesParams) ([]*PlexRefreshQueue, error) {
	rows, err := q.db.QueryContext(ctx, getPendingPlexRefreshes, arg.NotificationID, arg.ServerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PlexRefreshQueue{}
	for rows.Next() {
		var i PlexRefreshQueue
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.ServerID,
			&i.SectionKey,
			&i.Path,
			&i.QueuedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPlexRefreshesBySection = `-- name: GetPendingPlexRefreshesBySection :many
SELECT id, notification_id, server_id, section_key, path, queued_at FROM plex_refresh_queue
WHERE notification_id = ? AND server_id = ? AND section_key = ?
ORDER BY queued_at
`

type GetPendingPlexRefreshesBySectionParams struct {
	NotificationID int64  `json:"notification_id"`
	ServerID       string `json:"server_id"`
	SectionKey     int64  `json:"section_key"`
}

// Get pending refresh items for a specific notification, server, and section
func (q *Queries) GetPendingPlexRefreshesBySection(ctx context.Context, arg GetPendingPlexRefreshesBySectionParams) ([]*PlexRefreshQueue, error) {
	rows, err := q.db.QueryContext(ctx, getPendingPlexRefreshesBySection, arg.NotificationID, arg.ServerID, arg.SectionKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PlexRefreshQueue{}
	for rows.Next() {
		var i PlexRefreshQueue
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.ServerID,
			&i.SectionKey,
			&i.Path,
			&i.QueuedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
