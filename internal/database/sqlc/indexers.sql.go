// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: indexers.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countIndexers = `-- name: CountIndexers :one
SELECT COUNT(*) FROM indexers
`

func (q *Queries) CountIndexers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIndexers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIndexer = `-- name: CreateIndexer :one
INSERT INTO indexers (
    name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled, created_at, updated_at
`

type CreateIndexerParams struct {
	Name           string         `json:"name"`
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	ApiKey         sql.NullString `json:"api_key"`
	Categories     sql.NullString `json:"categories"`
	SupportsMovies int64          `json:"supports_movies"`
	SupportsTv     int64          `json:"supports_tv"`
	Priority       int64          `json:"priority"`
	Enabled        int64          `json:"enabled"`
}

func (q *Queries) CreateIndexer(ctx context.Context, arg CreateIndexerParams) (*Indexer, error) {
	row := q.db.QueryRowContext(ctx, createIndexer,
		arg.Name,
		arg.Type,
		arg.Url,
		arg.ApiKey,
		arg.Categories,
		arg.SupportsMovies,
		arg.SupportsTv,
		arg.Priority,
		arg.Enabled,
	)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Url,
		&i.ApiKey,
		&i.Categories,
		&i.SupportsMovies,
		&i.SupportsTv,
		&i.Priority,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteIndexer = `-- name: DeleteIndexer :exec
DELETE FROM indexers WHERE id = ?
`

func (q *Queries) DeleteIndexer(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteIndexer, id)
	return err
}

const getIndexer = `-- name: GetIndexer :one
SELECT id, name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled, created_at, updated_at FROM indexers WHERE id = ? LIMIT 1
`

func (q *Queries) GetIndexer(ctx context.Context, id int64) (*Indexer, error) {
	row := q.db.QueryRowContext(ctx, getIndexer, id)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Url,
		&i.ApiKey,
		&i.Categories,
		&i.SupportsMovies,
		&i.SupportsTv,
		&i.Priority,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listEnabledIndexers = `-- name: ListEnabledIndexers :many
SELECT id, name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled, created_at, updated_at FROM indexers WHERE enabled = 1 ORDER BY priority, name
`

func (q *Queries) ListEnabledIndexers(ctx context.Context) ([]*Indexer, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledIndexers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Indexer{}
	for rows.Next() {
		var i Indexer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Url,
			&i.ApiKey,
			&i.Categories,
			&i.SupportsMovies,
			&i.SupportsTv,
			&i.Priority,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndexers = `-- name: ListIndexers :many
SELECT id, name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled, created_at, updated_at FROM indexers ORDER BY priority, name
`

func (q *Queries) ListIndexers(ctx context.Context) ([]*Indexer, error) {
	rows, err := q.db.QueryContext(ctx, listIndexers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Indexer{}
	for rows.Next() {
		var i Indexer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Url,
			&i.ApiKey,
			&i.Categories,
			&i.SupportsMovies,
			&i.SupportsTv,
			&i.Priority,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIndexer = `-- name: UpdateIndexer :one
UPDATE indexers SET
    name = ?,
    type = ?,
    url = ?,
    api_key = ?,
    categories = ?,
    supports_movies = ?,
    supports_tv = ?,
    priority = ?,
    enabled = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, url, api_key, categories, supports_movies, supports_tv, priority, enabled, created_at, updated_at
`

type UpdateIndexerParams struct {
	Name           string         `json:"name"`
	Type           string         `json:"type"`
	Url            string         `json:"url"`
	ApiKey         sql.NullString `json:"api_key"`
	Categories     sql.NullString `json:"categories"`
	SupportsMovies int64          `json:"supports_movies"`
	SupportsTv     int64          `json:"supports_tv"`
	Priority       int64          `json:"priority"`
	Enabled        int64          `json:"enabled"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateIndexer(ctx context.Context, arg UpdateIndexerParams) (*Indexer, error) {
	row := q.db.QueryRowContext(ctx, updateIndexer,
		arg.Name,
		arg.Type,
		arg.Url,
		arg.ApiKey,
		arg.Categories,
		arg.SupportsMovies,
		arg.SupportsTv,
		arg.Priority,
		arg.Enabled,
		arg.ID,
	)
	var i Indexer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Url,
		&i.ApiKey,
		&i.Categories,
		&i.SupportsMovies,
		&i.SupportsTv,
		&i.Priority,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
