// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settings.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countHistory = `-- name: CountHistory :one
SELECT COUNT(*) FROM history
`

func (q *Queries) CountHistory(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countHistory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countHistoryByEventType = `-- name: CountHistoryByEventType :one
SELECT COUNT(*) FROM history WHERE event_type = ?
`

func (q *Queries) CountHistoryByEventType(ctx context.Context, eventType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countHistoryByEventType, eventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countHistoryByMediaType = `-- name: CountHistoryByMediaType :one
SELECT COUNT(*) FROM history WHERE media_type = ?
`

func (q *Queries) CountHistoryByMediaType(ctx context.Context, mediaType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countHistoryByMediaType, mediaType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countHistoryFiltered = `-- name: CountHistoryFiltered :one
SELECT COUNT(*) FROM history
WHERE (? = '' OR event_type = ?)
  AND (? = '' OR media_type = ?)
  AND (? = '' OR created_at >= ?)
  AND (? = '' OR created_at <= ?)
`

type CountHistoryFilteredParams struct {
	Column1     interface{}  `json:"column_1"`
	EventType   string       `json:"event_type"`
	Column3     interface{}  `json:"column_3"`
	MediaType   string       `json:"media_type"`
	Column5     interface{}  `json:"column_5"`
	CreatedAt   sql.NullTime `json:"created_at"`
	Column7     interface{}  `json:"column_7"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
}

func (q *Queries) CountHistoryFiltered(ctx context.Context, arg CountHistoryFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countHistoryFiltered,
		arg.Column1,
		arg.EventType,
		arg.Column3,
		arg.MediaType,
		arg.Column5,
		arg.CreatedAt,
		arg.Column7,
		arg.CreatedAt_2,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMoviesUsingProfile = `-- name: CountMoviesUsingProfile :one
SELECT COUNT(*) FROM movies WHERE quality_profile_id = ?
`

func (q *Queries) CountMoviesUsingProfile(ctx context.Context, qualityProfileID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMoviesUsingProfile, qualityProfileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeriesUsingProfile = `-- name: CountSeriesUsingProfile :one
SELECT COUNT(*) FROM series WHERE quality_profile_id = ?
`

func (q *Queries) CountSeriesUsingProfile(ctx context.Context, qualityProfileID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSeriesUsingProfile, qualityProfileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDownload = `-- name: CreateDownload :one
INSERT INTO downloads (
    client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path, added_at, completed_at
`

type CreateDownloadParams struct {
	ClientID    sql.NullInt64  `json:"client_id"`
	ExternalID  sql.NullString `json:"external_id"`
	Title       string         `json:"title"`
	MediaType   string         `json:"media_type"`
	MediaID     int64          `json:"media_id"`
	Status      string         `json:"status"`
	Progress    float64        `json:"progress"`
	Size        int64          `json:"size"`
	DownloadUrl sql.NullString `json:"download_url"`
	OutputPath  sql.NullString `json:"output_path"`
}

func (q *Queries) CreateDownload(ctx context.Context, arg CreateDownloadParams) (*Download, error) {
	row := q.db.QueryRowContext(ctx, createDownload,
		arg.ClientID,
		arg.ExternalID,
		arg.Title,
		arg.MediaType,
		arg.MediaID,
		arg.Status,
		arg.Progress,
		arg.Size,
		arg.DownloadUrl,
		arg.OutputPath,
	)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ExternalID,
		&i.Title,
		&i.MediaType,
		&i.MediaID,
		&i.Status,
		&i.Progress,
		&i.Size,
		&i.DownloadUrl,
		&i.OutputPath,
		&i.AddedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const createHistoryEntry = `-- name: CreateHistoryEntry :one
INSERT INTO history (event_type, media_type, media_id, source, quality, data)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, event_type, media_type, media_id, source, quality, data, created_at
`

type CreateHistoryEntryParams struct {
	EventType string         `json:"event_type"`
	MediaType string         `json:"media_type"`
	MediaID   int64          `json:"media_id"`
	Source    sql.NullString `json:"source"`
	Quality   sql.NullString `json:"quality"`
	Data      sql.NullString `json:"data"`
}

func (q *Queries) CreateHistoryEntry(ctx context.Context, arg CreateHistoryEntryParams) (*History, error) {
	row := q.db.QueryRowContext(ctx, createHistoryEntry,
		arg.EventType,
		arg.MediaType,
		arg.MediaID,
		arg.Source,
		arg.Quality,
		arg.Data,
	)
	var i History
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.MediaType,
		&i.MediaID,
		&i.Source,
		&i.Quality,
		&i.Data,
		&i.CreatedAt,
	)
	return &i, err
}

const createQualityProfile = `-- name: CreateQualityProfile :one
INSERT INTO quality_profiles (name, cutoff, items, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, cutoff, items, created_at, updated_at, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy
`

type CreateQualityProfileParams struct {
	Name                    string `json:"name"`
	Cutoff                  int64  `json:"cutoff"`
	Items                   string `json:"items"`
	HdrSettings             string `json:"hdr_settings"`
	VideoCodecSettings      string `json:"video_codec_settings"`
	AudioCodecSettings      string `json:"audio_codec_settings"`
	AudioChannelSettings    string `json:"audio_channel_settings"`
	UpgradesEnabled         int64  `json:"upgrades_enabled"`
	AllowAutoApprove        int64  `json:"allow_auto_approve"`
	UpgradeStrategy         string `json:"upgrade_strategy"`
	CutoffOverridesStrategy int64  `json:"cutoff_overrides_strategy"`
}

func (q *Queries) CreateQualityProfile(ctx context.Context, arg CreateQualityProfileParams) (*QualityProfile, error) {
	row := q.db.QueryRowContext(ctx, createQualityProfile,
		arg.Name,
		arg.Cutoff,
		arg.Items,
		arg.HdrSettings,
		arg.VideoCodecSettings,
		arg.AudioCodecSettings,
		arg.AudioChannelSettings,
		arg.UpgradesEnabled,
		arg.AllowAutoApprove,
		arg.UpgradeStrategy,
		arg.CutoffOverridesStrategy,
	)
	var i QualityProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cutoff,
		&i.Items,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HdrSettings,
		&i.VideoCodecSettings,
		&i.AudioCodecSettings,
		&i.AudioChannelSettings,
		&i.UpgradesEnabled,
		&i.AllowAutoApprove,
		&i.UpgradeStrategy,
		&i.CutoffOverridesStrategy,
	)
	return &i, err
}

const createRootFolder = `-- name: CreateRootFolder :one
INSERT INTO root_folders (path, name, media_type, free_space)
VALUES (?, ?, ?, ?)
RETURNING id, path, name, media_type, free_space, created_at
`

type CreateRootFolderParams struct {
	Path      string        `json:"path"`
	Name      string        `json:"name"`
	MediaType string        `json:"media_type"`
	FreeSpace sql.NullInt64 `json:"free_space"`
}

func (q *Queries) CreateRootFolder(ctx context.Context, arg CreateRootFolderParams) (*RootFolder, error) {
	row := q.db.QueryRowContext(ctx, createRootFolder,
		arg.Path,
		arg.Name,
		arg.MediaType,
		arg.FreeSpace,
	)
	var i RootFolder
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.MediaType,
		&i.FreeSpace,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteAllHistory = `-- name: DeleteAllHistory :exec
DELETE FROM history
`

func (q *Queries) DeleteAllHistory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllHistory)
	return err
}

const deleteDownload = `-- name: DeleteDownload :exec
DELETE FROM downloads WHERE id = ?
`

func (q *Queries) DeleteDownload(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDownload, id)
	return err
}

const deleteOldHistory = `-- name: DeleteOldHistory :exec
DELETE FROM history WHERE created_at < ?
`

func (q *Queries) DeleteOldHistory(ctx context.Context, createdAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteOldHistory, createdAt)
	return err
}

const deleteQualityProfile = `-- name: DeleteQualityProfile :exec
DELETE FROM quality_profiles WHERE id = ?
`

func (q *Queries) DeleteQualityProfile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQualityProfile, id)
	return err
}

const deleteRootFolder = `-- name: DeleteRootFolder :exec
DELETE FROM root_folders WHERE id = ?
`

func (q *Queries) DeleteRootFolder(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRootFolder, id)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings WHERE key = ?
`

func (q *Queries) DeleteSetting(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteSetting, key)
	return err
}

const getAllDefaults = `-- name: GetAllDefaults :many
SELECT "key", value, updated_at FROM settings WHERE key LIKE 'default_%' ORDER BY key
`

func (q *Queries) GetAllDefaults(ctx context.Context) ([]*Setting, error) {
	rows, err := q.db.QueryContext(ctx, getAllDefaults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultForEntityTypeAndMediaType = `-- name: GetDefaultForEntityTypeAndMediaType :one
SELECT "key", value, updated_at FROM settings WHERE key = ? LIMIT 1
`

// Default Settings
func (q *Queries) GetDefaultForEntityTypeAndMediaType(ctx context.Context, key string) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, getDefaultForEntityTypeAndMediaType, key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return &i, err
}

const getDefaultsForEntityType = `-- name: GetDefaultsForEntityType :many
SELECT "key", value, updated_at FROM settings WHERE key LIKE ? ORDER BY key
`

func (q *Queries) GetDefaultsForEntityType(ctx context.Context, key string) ([]*Setting, error) {
	rows, err := q.db.QueryContext(ctx, getDefaultsForEntityType, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDownload = `-- name: GetDownload :one
SELECT id, client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path, added_at, completed_at FROM downloads WHERE id = ? LIMIT 1
`

// Downloads Queue
func (q *Queries) GetDownload(ctx context.Context, id int64) (*Download, error) {
	row := q.db.QueryRowContext(ctx, getDownload, id)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ExternalID,
		&i.Title,
		&i.MediaType,
		&i.MediaID,
		&i.Status,
		&i.Progress,
		&i.Size,
		&i.DownloadUrl,
		&i.OutputPath,
		&i.AddedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const getQualityProfile = `-- name: GetQualityProfile :one
SELECT id, name, cutoff, items, created_at, updated_at, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy FROM quality_profiles WHERE id = ? LIMIT 1
`

// Quality Profiles
func (q *Queries) GetQualityProfile(ctx context.Context, id int64) (*QualityProfile, error) {
	row := q.db.QueryRowContext(ctx, getQualityProfile, id)
	var i QualityProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cutoff,
		&i.Items,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HdrSettings,
		&i.VideoCodecSettings,
		&i.AudioCodecSettings,
		&i.AudioChannelSettings,
		&i.UpgradesEnabled,
		&i.AllowAutoApprove,
		&i.UpgradeStrategy,
		&i.CutoffOverridesStrategy,
	)
	return &i, err
}

const getQualityProfileByName = `-- name: GetQualityProfileByName :one
SELECT id, name, cutoff, items, created_at, updated_at, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy FROM quality_profiles WHERE name = ? LIMIT 1
`

func (q *Queries) GetQualityProfileByName(ctx context.Context, name string) (*QualityProfile, error) {
	row := q.db.QueryRowContext(ctx, getQualityProfileByName, name)
	var i QualityProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cutoff,
		&i.Items,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HdrSettings,
		&i.VideoCodecSettings,
		&i.AudioCodecSettings,
		&i.AudioChannelSettings,
		&i.UpgradesEnabled,
		&i.AllowAutoApprove,
		&i.UpgradeStrategy,
		&i.CutoffOverridesStrategy,
	)
	return &i, err
}

const getRootFolder = `-- name: GetRootFolder :one
SELECT id, path, name, media_type, free_space, created_at FROM root_folders WHERE id = ? LIMIT 1
`

// Root Folders
func (q *Queries) GetRootFolder(ctx context.Context, id int64) (*RootFolder, error) {
	row := q.db.QueryRowContext(ctx, getRootFolder, id)
	var i RootFolder
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.MediaType,
		&i.FreeSpace,
		&i.CreatedAt,
	)
	return &i, err
}

const getRootFolderByPath = `-- name: GetRootFolderByPath :one
SELECT id, path, name, media_type, free_space, created_at FROM root_folders WHERE path = ? LIMIT 1
`

func (q *Queries) GetRootFolderByPath(ctx context.Context, path string) (*RootFolder, error) {
	row := q.db.QueryRowContext(ctx, getRootFolderByPath, path)
	var i RootFolder
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.MediaType,
		&i.FreeSpace,
		&i.CreatedAt,
	)
	return &i, err
}

const getSetting = `-- name: GetSetting :one
SELECT "key", value, updated_at FROM settings WHERE key = ? LIMIT 1
`

func (q *Queries) GetSetting(ctx context.Context, key string) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, getSetting, key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return &i, err
}

const listActiveDownloads = `-- name: ListActiveDownloads :many
SELECT id, client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path, added_at, completed_at FROM downloads WHERE status IN ('queued', 'downloading', 'paused') ORDER BY added_at
`

func (q *Queries) ListActiveDownloads(ctx context.Context) ([]*Download, error) {
	rows, err := q.db.QueryContext(ctx, listActiveDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Download{}
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ExternalID,
			&i.Title,
			&i.MediaType,
			&i.MediaID,
			&i.Status,
			&i.Progress,
			&i.Size,
			&i.DownloadUrl,
			&i.OutputPath,
			&i.AddedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloads = `-- name: ListDownloads :many
SELECT id, client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path, added_at, completed_at FROM downloads ORDER BY added_at DESC
`

func (q *Queries) ListDownloads(ctx context.Context) ([]*Download, error) {
	rows, err := q.db.QueryContext(ctx, listDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Download{}
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ExternalID,
			&i.Title,
			&i.MediaType,
			&i.MediaID,
			&i.Status,
			&i.Progress,
			&i.Size,
			&i.DownloadUrl,
			&i.OutputPath,
			&i.AddedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistory = `-- name: ListHistory :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history ORDER BY created_at DESC LIMIT ?
`

// History
func (q *Queries) ListHistory(ctx context.Context, limit int64) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistory, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistoryByEventType = `-- name: ListHistoryByEventType :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history
WHERE event_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListHistoryByEventTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListHistoryByEventType(ctx context.Context, arg ListHistoryByEventTypeParams) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistoryByEventType, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistoryByMedia = `-- name: ListHistoryByMedia :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history WHERE media_type = ? AND media_id = ? ORDER BY created_at DESC
`

type ListHistoryByMediaParams struct {
	MediaType string `json:"media_type"`
	MediaID   int64  `json:"media_id"`
}

func (q *Queries) ListHistoryByMedia(ctx context.Context, arg ListHistoryByMediaParams) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistoryByMedia, arg.MediaType, arg.MediaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistoryByMediaType = `-- name: ListHistoryByMediaType :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history
WHERE media_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListHistoryByMediaTypeParams struct {
	MediaType string `json:"media_type"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListHistoryByMediaType(ctx context.Context, arg ListHistoryByMediaTypeParams) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistoryByMediaType, arg.MediaType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistoryFiltered = `-- name: ListHistoryFiltered :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history
WHERE (? = '' OR event_type = ?)
  AND (? = '' OR media_type = ?)
  AND (? = '' OR created_at >= ?)
  AND (? = '' OR created_at <= ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListHistoryFilteredParams struct {
	Column1     interface{}  `json:"column_1"`
	EventType   string       `json:"event_type"`
	Column3     interface{}  `json:"column_3"`
	MediaType   string       `json:"media_type"`
	Column5     interface{}  `json:"column_5"`
	CreatedAt   sql.NullTime `json:"created_at"`
	Column7     interface{}  `json:"column_7"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
	Limit       int64        `json:"limit"`
	Offset      int64        `json:"offset"`
}

func (q *Queries) ListHistoryFiltered(ctx context.Context, arg ListHistoryFilteredParams) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistoryFiltered,
		arg.Column1,
		arg.EventType,
		arg.Column3,
		arg.MediaType,
		arg.Column5,
		arg.CreatedAt,
		arg.Column7,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHistoryPaginated = `-- name: ListHistoryPaginated :many
SELECT id, event_type, media_type, media_id, source, quality, data, created_at FROM history
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListHistoryPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListHistoryPaginated(ctx context.Context, arg ListHistoryPaginatedParams) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, listHistoryPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*History{}
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.MediaType,
			&i.MediaID,
			&i.Source,
			&i.Quality,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQualityProfiles = `-- name: ListQualityProfiles :many
SELECT id, name, cutoff, items, created_at, updated_at, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy FROM quality_profiles ORDER BY name
`

func (q *Queries) ListQualityProfiles(ctx context.Context) ([]*QualityProfile, error) {
	rows, err := q.db.QueryContext(ctx, listQualityProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QualityProfile{}
	for rows.Next() {
		var i QualityProfile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Cutoff,
			&i.Items,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HdrSettings,
			&i.VideoCodecSettings,
			&i.AudioCodecSettings,
			&i.AudioChannelSettings,
			&i.UpgradesEnabled,
			&i.AllowAutoApprove,
			&i.UpgradeStrategy,
			&i.CutoffOverridesStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFolders = `-- name: ListRootFolders :many
SELECT id, path, name, media_type, free_space, created_at FROM root_folders ORDER BY name
`

func (q *Queries) ListRootFolders(ctx context.Context) ([]*RootFolder, error) {
	rows, err := q.db.QueryContext(ctx, listRootFolders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*RootFolder{}
	for rows.Next() {
		var i RootFolder
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.MediaType,
			&i.FreeSpace,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFoldersByMediaType = `-- name: ListRootFoldersByMediaType :many
SELECT id, path, name, media_type, free_space, created_at FROM root_folders WHERE media_type = ? ORDER BY name
`

func (q *Queries) ListRootFoldersByMediaType(ctx context.Context, mediaType string) ([]*RootFolder, error) {
	rows, err := q.db.QueryContext(ctx, listRootFoldersByMediaType, mediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*RootFolder{}
	for rows.Next() {
		var i RootFolder
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.MediaType,
			&i.FreeSpace,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFoldersByType = `-- name: ListRootFoldersByType :many
SELECT id, path, name, media_type, free_space, created_at FROM root_folders WHERE media_type = ? ORDER BY name
`

func (q *Queries) ListRootFoldersByType(ctx context.Context, mediaType string) ([]*RootFolder, error) {
	rows, err := q.db.QueryContext(ctx, listRootFoldersByType, mediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*RootFolder{}
	for rows.Next() {
		var i RootFolder
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.MediaType,
			&i.FreeSpace,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettings = `-- name: ListSettings :many
SELECT "key", value, updated_at FROM settings ORDER BY key
`

func (q *Queries) ListSettings(ctx context.Context) ([]*Setting, error) {
	rows, err := q.db.QueryContext(ctx, listSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultForEntityTypeAndMediaType = `-- name: SetDefaultForEntityTypeAndMediaType :one
INSERT INTO settings (key, value, updated_at)
VALUES (?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(key) DO UPDATE SET
    value = excluded.value,
    updated_at = CURRENT_TIMESTAMP
RETURNING "key", value, updated_at
`

type SetDefaultForEntityTypeAndMediaTypeParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) SetDefaultForEntityTypeAndMediaType(ctx context.Context, arg SetDefaultForEntityTypeAndMediaTypeParams) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, setDefaultForEntityTypeAndMediaType, arg.Key, arg.Value)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return &i, err
}

const setSetting = `-- name: SetSetting :one
INSERT INTO settings (key, value, updated_at)
VALUES (?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(key) DO UPDATE SET
    value = excluded.value,
    updated_at = CURRENT_TIMESTAMP
RETURNING "key", value, updated_at
`

type SetSettingParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) SetSetting(ctx context.Context, arg SetSettingParams) (*Setting, error) {
	row := q.db.QueryRowContext(ctx, setSetting, arg.Key, arg.Value)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return &i, err
}

const updateDownloadStatus = `-- name: UpdateDownloadStatus :one
UPDATE downloads SET
    status = ?,
    progress = ?,
    completed_at = CASE WHEN ? = 'completed' THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE id = ?
RETURNING id, client_id, external_id, title, media_type, media_id, status, progress, size, download_url, output_path, added_at, completed_at
`

type UpdateDownloadStatusParams struct {
	Status   string      `json:"status"`
	Progress float64     `json:"progress"`
	Column3  interface{} `json:"column_3"`
	ID       int64       `json:"id"`
}

func (q *Queries) UpdateDownloadStatus(ctx context.Context, arg UpdateDownloadStatusParams) (*Download, error) {
	row := q.db.QueryRowContext(ctx, updateDownloadStatus,
		arg.Status,
		arg.Progress,
		arg.Column3,
		arg.ID,
	)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ExternalID,
		&i.Title,
		&i.MediaType,
		&i.MediaID,
		&i.Status,
		&i.Progress,
		&i.Size,
		&i.DownloadUrl,
		&i.OutputPath,
		&i.AddedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateQualityProfile = `-- name: UpdateQualityProfile :one
UPDATE quality_profiles SET
    name = ?,
    cutoff = ?,
    items = ?,
    hdr_settings = ?,
    video_codec_settings = ?,
    audio_codec_settings = ?,
    audio_channel_settings = ?,
    upgrades_enabled = ?,
    allow_auto_approve = ?,
    upgrade_strategy = ?,
    cutoff_overrides_strategy = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, cutoff, items, created_at, updated_at, hdr_settings, video_codec_settings, audio_codec_settings, audio_channel_settings, upgrades_enabled, allow_auto_approve, upgrade_strategy, cutoff_overrides_strategy
`

type UpdateQualityProfileParams struct {
	Name                    string `json:"name"`
	Cutoff                  int64  `json:"cutoff"`
	Items                   string `json:"items"`
	HdrSettings             string `json:"hdr_settings"`
	VideoCodecSettings      string `json:"video_codec_settings"`
	AudioCodecSettings      string `json:"audio_codec_settings"`
	AudioChannelSettings    string `json:"audio_channel_settings"`
	UpgradesEnabled         int64  `json:"upgrades_enabled"`
	AllowAutoApprove        int64  `json:"allow_auto_approve"`
	UpgradeStrategy         string `json:"upgrade_strategy"`
	CutoffOverridesStrategy int64  `json:"cutoff_overrides_strategy"`
	ID                      int64  `json:"id"`
}

func (q *Queries) UpdateQualityProfile(ctx context.Context, arg UpdateQualityProfileParams) (*QualityProfile, error) {
	row := q.db.QueryRowContext(ctx, updateQualityProfile,
		arg.Name,
		arg.Cutoff,
		arg.Items,
		arg.HdrSettings,
		arg.VideoCodecSettings,
		arg.AudioCodecSettings,
		arg.AudioChannelSettings,
		arg.UpgradesEnabled,
		arg.AllowAutoApprove,
		arg.UpgradeStrategy,
		arg.CutoffOverridesStrategy,
		arg.ID,
	)
	var i QualityProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cutoff,
		&i.Items,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HdrSettings,
		&i.VideoCodecSettings,
		&i.AudioCodecSettings,
		&i.AudioChannelSettings,
		&i.UpgradesEnabled,
		&i.AllowAutoApprove,
		&i.UpgradeStrategy,
		&i.CutoffOverridesStrategy,
	)
	return &i, err
}

const updateRootFolder = `-- name: UpdateRootFolder :one
UPDATE root_folders SET
    path = ?,
    name = ?,
    free_space = ?
WHERE id = ?
RETURNING id, path, name, media_type, free_space, created_at
`

type UpdateRootFolderParams struct {
	Path      string        `json:"path"`
	Name      string        `json:"name"`
	FreeSpace sql.NullInt64 `json:"free_space"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateRootFolder(ctx context.Context, arg UpdateRootFolderParams) (*RootFolder, error) {
	row := q.db.QueryRowContext(ctx, updateRootFolder,
		arg.Path,
		arg.Name,
		arg.FreeSpace,
		arg.ID,
	)
	var i RootFolder
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.MediaType,
		&i.FreeSpace,
		&i.CreatedAt,
	)
	return &i, err
}

const updateRootFolderFreeSpace = `-- name: UpdateRootFolderFreeSpace :exec
UPDATE root_folders SET free_space = ? WHERE id = ?
`

type UpdateRootFolderFreeSpaceParams struct {
	FreeSpace sql.NullInt64 `json:"free_space"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateRootFolderFreeSpace(ctx context.Context, arg UpdateRootFolderFreeSpaceParams) error {
	_, err := q.db.ExecContext(ctx, updateRootFolderFreeSpace, arg.FreeSpace, arg.ID)
	return err
}
