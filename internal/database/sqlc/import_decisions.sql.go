// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: import_decisions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const cleanupAllImportDecisions = `-- name: CleanupAllImportDecisions :exec
DELETE FROM import_decisions
`

func (q *Queries) CleanupAllImportDecisions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupAllImportDecisions)
	return err
}

const deleteImportDecision = `-- name: DeleteImportDecision :exec
DELETE FROM import_decisions WHERE source_path = ?
`

func (q *Queries) DeleteImportDecision(ctx context.Context, sourcePath string) error {
	_, err := q.db.ExecContext(ctx, deleteImportDecision, sourcePath)
	return err
}

const deleteImportDecisionsByExistingFile = `-- name: DeleteImportDecisionsByExistingFile :exec
DELETE FROM import_decisions WHERE existing_file_id = ?
`

func (q *Queries) DeleteImportDecisionsByExistingFile(ctx context.Context, existingFileID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteImportDecisionsByExistingFile, existingFileID)
	return err
}

const deleteImportDecisionsByMediaItem = `-- name: DeleteImportDecisionsByMediaItem :exec
DELETE FROM import_decisions WHERE media_type = ? AND media_id = ?
`

type DeleteImportDecisionsByMediaItemParams struct {
	MediaType string `json:"media_type"`
	MediaID   int64  `json:"media_id"`
}

func (q *Queries) DeleteImportDecisionsByMediaItem(ctx context.Context, arg DeleteImportDecisionsByMediaItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteImportDecisionsByMediaItem, arg.MediaType, arg.MediaID)
	return err
}

const deleteImportDecisionsByPathPrefix = `-- name: DeleteImportDecisionsByPathPrefix :exec
DELETE FROM import_decisions WHERE source_path LIKE ? || '%'
`

func (q *Queries) DeleteImportDecisionsByPathPrefix(ctx context.Context, dollar_1 sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteImportDecisionsByPathPrefix, dollar_1)
	return err
}

const deleteImportDecisionsByProfile = `-- name: DeleteImportDecisionsByProfile :exec
DELETE FROM import_decisions WHERE quality_profile_id = ?
`

func (q *Queries) DeleteImportDecisionsByProfile(ctx context.Context, qualityProfileID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteImportDecisionsByProfile, qualityProfileID)
	return err
}

const getImportDecision = `-- name: GetImportDecision :one
SELECT id, source_path, decision, media_type, media_id, slot_id, candidate_quality_id, existing_quality_id, existing_file_id, quality_profile_id, reason, evaluated_at FROM import_decisions WHERE source_path = ? LIMIT 1
`

func (q *Queries) GetImportDecision(ctx context.Context, sourcePath string) (*ImportDecision, error) {
	row := q.db.QueryRowContext(ctx, getImportDecision, sourcePath)
	var i ImportDecision
	err := row.Scan(
		&i.ID,
		&i.SourcePath,
		&i.Decision,
		&i.MediaType,
		&i.MediaID,
		&i.SlotID,
		&i.CandidateQualityID,
		&i.ExistingQualityID,
		&i.ExistingFileID,
		&i.QualityProfileID,
		&i.Reason,
		&i.EvaluatedAt,
	)
	return &i, err
}

const upsertImportDecision = `-- name: UpsertImportDecision :one
INSERT INTO import_decisions (
    source_path, decision, media_type, media_id, slot_id,
    candidate_quality_id, existing_quality_id, existing_file_id,
    quality_profile_id, reason, evaluated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT (source_path) DO UPDATE SET
    decision = excluded.decision,
    media_type = excluded.media_type,
    media_id = excluded.media_id,
    slot_id = excluded.slot_id,
    candidate_quality_id = excluded.candidate_quality_id,
    existing_quality_id = excluded.existing_quality_id,
    existing_file_id = excluded.existing_file_id,
    quality_profile_id = excluded.quality_profile_id,
    reason = excluded.reason,
    evaluated_at = CURRENT_TIMESTAMP
RETURNING id, source_path, decision, media_type, media_id, slot_id, candidate_quality_id, existing_quality_id, existing_file_id, quality_profile_id, reason, evaluated_at
`

type UpsertImportDecisionParams struct {
	SourcePath         string         `json:"source_path"`
	Decision           string         `json:"decision"`
	MediaType          string         `json:"media_type"`
	MediaID            int64          `json:"media_id"`
	SlotID             sql.NullInt64  `json:"slot_id"`
	CandidateQualityID sql.NullInt64  `json:"candidate_quality_id"`
	ExistingQualityID  sql.NullInt64  `json:"existing_quality_id"`
	ExistingFileID     sql.NullInt64  `json:"existing_file_id"`
	QualityProfileID   sql.NullInt64  `json:"quality_profile_id"`
	Reason             sql.NullString `json:"reason"`
}

func (q *Queries) UpsertImportDecision(ctx context.Context, arg UpsertImportDecisionParams) (*ImportDecision, error) {
	row := q.db.QueryRowContext(ctx, upsertImportDecision,
		arg.SourcePath,
		arg.Decision,
		arg.MediaType,
		arg.MediaID,
		arg.SlotID,
		arg.CandidateQualityID,
		arg.ExistingQualityID,
		arg.ExistingFileID,
		arg.QualityProfileID,
		arg.Reason,
	)
	var i ImportDecision
	err := row.Scan(
		&i.ID,
		&i.SourcePath,
		&i.Decision,
		&i.MediaType,
		&i.MediaID,
		&i.SlotID,
		&i.CandidateQualityID,
		&i.ExistingQualityID,
		&i.ExistingFileID,
		&i.QualityProfileID,
		&i.Reason,
		&i.EvaluatedAt,
	)
	return &i, err
}
