// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countMissingMovies = `-- name: CountMissingMovies :one
SELECT COUNT(*) FROM movies m
WHERE m.status IN ('missing', 'failed')
  AND m.monitored = 1
`

func (q *Queries) CountMissingMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMissingMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = 1
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFiles = `-- name: CountMovieFiles :one
SELECT COUNT(*) FROM movie_files WHERE movie_id = ?
`

func (q *Queries) CountMovieFiles(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFiles, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieUpgradeCandidates = `-- name: CountMovieUpgradeCandidates :one
SELECT COUNT(*) FROM movies m
WHERE m.status = 'upgradable'
  AND m.monitored = 1
`

func (q *Queries) CountMovieUpgradeCandidates(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieUpgradeCandidates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    title, sort_title, year, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, status,
    release_date, physical_release_date
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at
`

type CreateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.PhysicalReleaseDate,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO movie_files (movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type CreateMovieFileParams struct {
	MovieID    int64          `json:"movie_id"`
	Path       string         `json:"path"`
	Size       int64          `json:"size"`
	Quality    sql.NullString `json:"quality"`
	QualityID  sql.NullInt64  `json:"quality_id"`
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
}

func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFile,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const createMovieFileWithImportInfo = `-- name: CreateMovieFileWithImportInfo :one
INSERT INTO movie_files (
    movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution,
    original_path, original_filename, imported_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type CreateMovieFileWithImportInfoParams struct {
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
}

// Import-related movie file operations
func (q *Queries) CreateMovieFileWithImportInfo(ctx context.Context, arg CreateMovieFileWithImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFileWithImportInfo,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
DELETE FROM movie_files WHERE id = ?
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieFilesByMovie = `-- name: DeleteMovieFilesByMovie :exec
DELETE FROM movie_files WHERE movie_id = ?
`

func (q *Queries) DeleteMovieFilesByMovie(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFilesByMovie, movieID)
	return err
}

const deleteMoviesByRootFolder = `-- name: DeleteMoviesByRootFolder :exec
DELETE FROM movies WHERE root_folder_id = ?
`

func (q *Queries) DeleteMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMoviesByRootFolder, rootFolderID)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies WHERE id = ? LIMIT 1
`

func (q *Queries) GetMovie(ctx context.Context, id int64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path sql.NullString) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE id = ? LIMIT 1
`

// Movie Files
func (q *Queries) GetMovieFile(ctx context.Context, id int64) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const getMovieFileByOriginalPath = `-- name: GetMovieFileByOriginalPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE original_path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByOriginalPath(ctx context.Context, originalPath sql.NullString) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByOriginalPath, originalPath)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByPath, path)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const getMovieFilesWithImportInfo = `-- name: GetMovieFilesWithImportInfo :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE movie_id = ? ORDER BY imported_at DESC
`

func (q *Queries) GetMovieFilesWithImportInfo(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, getMovieFilesWithImportInfo, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieWithFileQuality = `-- name: GetMovieWithFileQuality :one
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, mf.id as file_id, mf.quality_id as current_quality_id
FROM movies m
LEFT JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.id = ?
LIMIT 1
`

type GetMovieWithFileQualityRow struct {
	ID                  int64          `json:"id"`
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ActiveDownloadID    sql.NullString `json:"active_download_id"`
	StatusMessage       sql.NullString `json:"status_message"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	AddedAt             sql.NullTime   `json:"added_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	FileID              sql.NullInt64  `json:"file_id"`
	CurrentQualityID    sql.NullInt64  `json:"current_quality_id"`
}

func (q *Queries) GetMovieWithFileQuality(ctx context.Context, id int64) (*GetMovieWithFileQualityRow, error) {
	row := q.db.QueryRowContext(ctx, getMovieWithFileQuality, id)
	var i GetMovieWithFileQualityRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.FileID,
		&i.CurrentQualityID,
	)
	return &i, err
}

const getMoviesInDateRange = `-- name: GetMoviesInDateRange :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies
WHERE (release_date BETWEEN ? AND ?)
   OR (physical_release_date BETWEEN ? AND ?)
ORDER BY COALESCE(release_date, physical_release_date)
`

type GetMoviesInDateRangeParams struct {
	FromReleaseDate         sql.NullTime `json:"from_release_date"`
	ToReleaseDate           sql.NullTime `json:"to_release_date"`
	FromPhysicalReleaseDate sql.NullTime `json:"from_physical_release_date"`
	ToPhysicalReleaseDate   sql.NullTime `json:"to_physical_release_date"`
}

// Calendar queries
func (q *Queries) GetMoviesInDateRange(ctx context.Context, arg GetMoviesInDateRangeParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getMoviesInDateRange,
		arg.FromReleaseDate,
		arg.ToReleaseDate,
		arg.FromPhysicalReleaseDate,
		arg.ToPhysicalReleaseDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreleasedMoviesWithPastDate = `-- name: GetUnreleasedMoviesWithPastDate :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies
WHERE status = 'unreleased' AND release_date IS NOT NULL AND release_date <= date('now')
`

func (q *Queries) GetUnreleasedMoviesWithPastDate(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getUnreleasedMoviesWithPastDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isOriginalPathImportedMovie = `-- name: IsOriginalPathImportedMovie :one
SELECT EXISTS(SELECT 1 FROM movie_files WHERE original_path = ?) AS imported
`

func (q *Queries) IsOriginalPathImportedMovie(ctx context.Context, originalPath sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, isOriginalPathImportedMovie, originalPath)
	var imported int64
	err := row.Scan(&imported)
	return imported, err
}

const listDownloadingMovies = `-- name: ListDownloadingMovies :many
SELECT id, active_download_id FROM movies
WHERE status = 'downloading' AND active_download_id IS NOT NULL
`

type ListDownloadingMoviesRow struct {
	ID               int64          `json:"id"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
}

func (q *Queries) ListDownloadingMovies(ctx context.Context) ([]*ListDownloadingMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDownloadingMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListDownloadingMoviesRow{}
	for rows.Next() {
		var i ListDownloadingMoviesRow
		if err := rows.Scan(&i.ID, &i.ActiveDownloadID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMissingMovies = `-- name: ListMissingMovies :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at FROM movies m
WHERE m.status IN ('missing', 'failed')
  AND m.monitored = 1
ORDER BY m.release_date DESC
`

// Missing movies queries (status-based)
func (q *Queries) ListMissingMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMissingMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredMovies = `-- name: ListMonitoredMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFiles = `-- name: ListMovieFiles :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE movie_id = ? ORDER BY path
`

func (q *Queries) ListMovieFiles(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFiles, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFilesForRootFolder = `-- name: ListMovieFilesForRootFolder :many
SELECT mf.id as file_id, mf.path, mf.movie_id, m.status as movie_status
FROM movie_files mf
JOIN movies m ON mf.movie_id = m.id
WHERE m.root_folder_id = ?
  AND m.status IN ('available', 'upgradable')
`

type ListMovieFilesForRootFolderRow struct {
	FileID      int64  `json:"file_id"`
	Path        string `json:"path"`
	MovieID     int64  `json:"movie_id"`
	MovieStatus string `json:"movie_status"`
}

func (q *Queries) ListMovieFilesForRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*ListMovieFilesForRootFolderRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFilesForRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieFilesForRootFolderRow{}
	for rows.Next() {
		var i ListMovieFilesForRootFolderRow
		if err := rows.Scan(
			&i.FileID,
			&i.Path,
			&i.MovieID,
			&i.MovieStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieUpgradeCandidates = `-- name: ListMovieUpgradeCandidates :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at FROM movies m
WHERE m.status = 'upgradable'
  AND m.monitored = 1
ORDER BY m.release_date DESC
`

// Upgrade candidate queries (status-based)
func (q *Queries) ListMovieUpgradeCandidates(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovieUpgradeCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies ORDER BY sort_title
`

func (q *Queries) ListMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByRootFolder = `-- name: ListMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesPaginated = `-- name: ListMoviesPaginated :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListMoviesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListMoviesPaginated(ctx context.Context, arg ListMoviesPaginatedParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesWithFilesForProfile = `-- name: ListMoviesWithFilesForProfile :many
SELECT m.id, m.status, mf.id as file_id, mf.quality_id as current_quality_id
FROM movies m
JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.quality_profile_id = ?
  AND m.status IN ('available', 'upgradable')
  AND mf.quality_id IS NOT NULL
`

type ListMoviesWithFilesForProfileRow struct {
	ID               int64         `json:"id"`
	Status           string        `json:"status"`
	FileID           int64         `json:"file_id"`
	CurrentQualityID sql.NullInt64 `json:"current_quality_id"`
}

// Quality profile recalculation: find movies with files to evaluate against new cutoff
func (q *Queries) ListMoviesWithFilesForProfile(ctx context.Context, qualityProfileID sql.NullInt64) ([]*ListMoviesWithFilesForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesWithFilesForProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMoviesWithFilesForProfileRow{}
	for rows.Next() {
		var i ListMoviesWithFilesForProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedMoviesByRootFolder = `-- name: ListUnmatchedMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies
WHERE root_folder_id = ?
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at FROM movies
WHERE title LIKE ? OR sort_title LIKE ?
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type SearchMoviesParams struct {
	Title     string `json:"title"`
	SortTitle string `json:"sort_title"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, searchMovies,
		arg.Title,
		arg.SortTitle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = ?,
    sort_title = ?,
    year = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    status = ?,
    release_date = ?,
    physical_release_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at
`

type UpdateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	ID                  int64          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.PhysicalReleaseDate,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateMovieFileImportInfo = `-- name: UpdateMovieFileImportInfo :one
UPDATE movie_files SET
    original_path = ?,
    original_filename = ?,
    imported_at = ?
WHERE id = ?
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type UpdateMovieFileImportInfoParams struct {
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovieFileImportInfo(ctx context.Context, arg UpdateMovieFileImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, updateMovieFileImportInfo,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
		arg.ID,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const updateMovieFileMediaInfo = `-- name: UpdateMovieFileMediaInfo :exec
UPDATE movie_files SET
    video_codec = ?,
    audio_codec = ?,
    resolution = ?
WHERE movie_id = ?
`

type UpdateMovieFileMediaInfoParams struct {
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
	MovieID    int64          `json:"movie_id"`
}

func (q *Queries) UpdateMovieFileMediaInfo(ctx context.Context, arg UpdateMovieFileMediaInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFileMediaInfo,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.MovieID,
	)
	return err
}

const updateMovieFilePath = `-- name: UpdateMovieFilePath :exec
UPDATE movie_files SET path = ? WHERE id = ?
`

type UpdateMovieFilePathParams struct {
	Path string `json:"path"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateMovieFilePath(ctx context.Context, arg UpdateMovieFilePathParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFilePath, arg.Path, arg.ID)
	return err
}

const updateMovieFileQualityID = `-- name: UpdateMovieFileQualityID :exec
UPDATE movie_files SET quality_id = ? WHERE id = ?
`

type UpdateMovieFileQualityIDParams struct {
	QualityID sql.NullInt64 `json:"quality_id"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateMovieFileQualityID(ctx context.Context, arg UpdateMovieFileQualityIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFileQualityID, arg.QualityID, arg.ID)
	return err
}

const updateMovieMonitored = `-- name: UpdateMovieMonitored :exec
UPDATE movies SET monitored = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateMovieMonitored(ctx context.Context, arg UpdateMovieMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieMonitored, arg.Monitored, arg.ID)
	return err
}

const updateMovieReleaseDates = `-- name: UpdateMovieReleaseDates :exec
UPDATE movies SET
    release_date = ?,
    physical_release_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieReleaseDatesParams struct {
	ReleaseDate         sql.NullTime `json:"release_date"`
	PhysicalReleaseDate sql.NullTime `json:"physical_release_date"`
	ID                  int64        `json:"id"`
}

func (q *Queries) UpdateMovieReleaseDates(ctx context.Context, arg UpdateMovieReleaseDatesParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleaseDates, arg.ReleaseDate, arg.PhysicalReleaseDate, arg.ID)
	return err
}

const updateMovieStatus = `-- name: UpdateMovieStatus :exec
UPDATE movies SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMovieStatus(ctx context.Context, arg UpdateMovieStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatus, arg.Status, arg.ID)
	return err
}

const updateMovieStatusWithDetails = `-- name: UpdateMovieStatusWithDetails :exec
UPDATE movies SET
    status = ?,
    active_download_id = ?,
    status_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieStatusWithDetailsParams struct {
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovieStatusWithDetails(ctx context.Context, arg UpdateMovieStatusWithDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatusWithDetails,
		arg.Status,
		arg.ActiveDownloadID,
		arg.StatusMessage,
		arg.ID,
	)
	return err
}

const updateMoviesToUnreleased = `-- name: UpdateMoviesToUnreleased :execresult
UPDATE movies SET status = 'unreleased', updated_at = CURRENT_TIMESTAMP
WHERE status = 'missing' AND (release_date IS NULL OR release_date > date('now'))
`

func (q *Queries) UpdateMoviesToUnreleased(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMoviesToUnreleased)
}

const updateUnreleasedMoviesToMissing = `-- name: UpdateUnreleasedMoviesToMissing :execresult
UPDATE movies SET status = 'missing', updated_at = CURRENT_TIMESTAMP
WHERE status = 'unreleased' AND release_date IS NOT NULL AND release_date <= date('now')
`

// Status refresh queries
func (q *Queries) UpdateUnreleasedMoviesToMissing(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUnreleasedMoviesToMissing)
}
