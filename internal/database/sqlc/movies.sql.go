// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = 1
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFiles = `-- name: CountMovieFiles :one
SELECT COUNT(*) FROM movie_files WHERE movie_id = ?
`

func (q *Queries) CountMovieFiles(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFiles, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    title, sort_title, year, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at
`

type CreateMovieParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	Status           string         `json:"status"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO movie_files (movie_id, path, size, quality, video_codec, audio_codec, resolution)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at
`

type CreateMovieFileParams struct {
	MovieID    int64          `json:"movie_id"`
	Path       string         `json:"path"`
	Size       int64          `json:"size"`
	Quality    sql.NullString `json:"quality"`
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
}

func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFile,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
DELETE FROM movie_files WHERE id = ?
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieFilesByMovie = `-- name: DeleteMovieFilesByMovie :exec
DELETE FROM movie_files WHERE movie_id = ?
`

func (q *Queries) DeleteMovieFilesByMovie(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFilesByMovie, movieID)
	return err
}

const deleteMoviesByRootFolder = `-- name: DeleteMoviesByRootFolder :exec
DELETE FROM movies WHERE root_folder_id = ?
`

func (q *Queries) DeleteMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMoviesByRootFolder, rootFolderID)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies WHERE id = ? LIMIT 1
`

func (q *Queries) GetMovie(ctx context.Context, id int64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path sql.NullString) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE id = ? LIMIT 1
`

// Movie Files
func (q *Queries) GetMovieFile(ctx context.Context, id int64) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByPath, path)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const listMonitoredMovies = `-- name: ListMonitoredMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFiles = `-- name: ListMovieFiles :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE movie_id = ? ORDER BY path
`

func (q *Queries) ListMovieFiles(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFiles, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies ORDER BY sort_title
`

func (q *Queries) ListMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByRootFolder = `-- name: ListMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesPaginated = `-- name: ListMoviesPaginated :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListMoviesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListMoviesPaginated(ctx context.Context, arg ListMoviesPaginatedParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedMoviesByRootFolder = `-- name: ListUnmatchedMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies
WHERE root_folder_id = ?
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at FROM movies
WHERE title LIKE ? OR sort_title LIKE ?
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type SearchMoviesParams struct {
	Title     string `json:"title"`
	SortTitle string `json:"sort_title"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, searchMovies,
		arg.Title,
		arg.SortTitle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = ?,
    sort_title = ?,
    year = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at
`

type UpdateMovieParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	Status           string         `json:"status"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateMovieStatus = `-- name: UpdateMovieStatus :exec
UPDATE movies SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMovieStatus(ctx context.Context, arg UpdateMovieStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatus, arg.Status, arg.ID)
	return err
}
