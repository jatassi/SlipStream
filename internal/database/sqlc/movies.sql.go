// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = 1
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFiles = `-- name: CountMovieFiles :one
SELECT COUNT(*) FROM movie_files WHERE movie_id = ?
`

func (q *Queries) CountMovieFiles(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFiles, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    title, sort_title, year, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, status,
    release_date, digital_release_date, physical_release_date, released
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status
`

type CreateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.Released,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO movie_files (movie_id, path, size, quality, video_codec, audio_codec, resolution)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at
`

type CreateMovieFileParams struct {
	MovieID    int64          `json:"movie_id"`
	Path       string         `json:"path"`
	Size       int64          `json:"size"`
	Quality    sql.NullString `json:"quality"`
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
}

func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFile,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
DELETE FROM movie_files WHERE id = ?
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieFilesByMovie = `-- name: DeleteMovieFilesByMovie :exec
DELETE FROM movie_files WHERE movie_id = ?
`

func (q *Queries) DeleteMovieFilesByMovie(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFilesByMovie, movieID)
	return err
}

const deleteMoviesByRootFolder = `-- name: DeleteMoviesByRootFolder :exec
DELETE FROM movies WHERE root_folder_id = ?
`

func (q *Queries) DeleteMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMoviesByRootFolder, rootFolderID)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE id = ? LIMIT 1
`

func (q *Queries) GetMovie(ctx context.Context, id int64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path sql.NullString) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE id = ? LIMIT 1
`

// Movie Files
func (q *Queries) GetMovieFile(ctx context.Context, id int64) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByPath, path)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const getMoviesInDateRange = `-- name: GetMoviesInDateRange :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE (release_date BETWEEN ? AND ?)
   OR (digital_release_date BETWEEN ? AND ?)
   OR (physical_release_date BETWEEN ? AND ?)
ORDER BY COALESCE(release_date, digital_release_date, physical_release_date)
`

type GetMoviesInDateRangeParams struct {
	FromReleaseDate         sql.NullTime `json:"from_release_date"`
	ToReleaseDate           sql.NullTime `json:"to_release_date"`
	FromDigitalReleaseDate  sql.NullTime `json:"from_digital_release_date"`
	ToDigitalReleaseDate    sql.NullTime `json:"to_digital_release_date"`
	FromPhysicalReleaseDate sql.NullTime `json:"from_physical_release_date"`
	ToPhysicalReleaseDate   sql.NullTime `json:"to_physical_release_date"`
}

// Calendar queries
func (q *Queries) GetMoviesInDateRange(ctx context.Context, arg GetMoviesInDateRangeParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getMoviesInDateRange,
		arg.FromReleaseDate,
		arg.ToReleaseDate,
		arg.FromDigitalReleaseDate,
		arg.ToDigitalReleaseDate,
		arg.FromPhysicalReleaseDate,
		arg.ToPhysicalReleaseDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreleasedMoviesWithPastDate = `-- name: GetUnreleasedMoviesWithPastDate :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE released = 0 AND release_date IS NOT NULL AND release_date <= date('now')
`

func (q *Queries) GetUnreleasedMoviesWithPastDate(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getUnreleasedMoviesWithPastDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredMovies = `-- name: ListMonitoredMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFiles = `-- name: ListMovieFiles :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM movie_files WHERE movie_id = ? ORDER BY path
`

func (q *Queries) ListMovieFiles(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFiles, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies ORDER BY sort_title
`

func (q *Queries) ListMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByRootFolder = `-- name: ListMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesPaginated = `-- name: ListMoviesPaginated :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListMoviesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListMoviesPaginated(ctx context.Context, arg ListMoviesPaginatedParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedMoviesByRootFolder = `-- name: ListUnmatchedMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE root_folder_id = ?
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE title LIKE ? OR sort_title LIKE ?
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type SearchMoviesParams struct {
	Title     string `json:"title"`
	SortTitle string `json:"sort_title"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, searchMovies,
		arg.Title,
		arg.SortTitle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAllMoviesAvailabilityStatus = `-- name: UpdateAllMoviesAvailabilityStatus :execresult
UPDATE movies SET
    availability_status = CASE WHEN released = 1 THEN 'Available' ELSE 'Unreleased' END,
    updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) UpdateAllMoviesAvailabilityStatus(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAllMoviesAvailabilityStatus)
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = ?,
    sort_title = ?,
    year = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    status = ?,
    release_date = ?,
    digital_release_date = ?,
    physical_release_date = ?,
    released = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status
`

type UpdateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
	ID                  int64          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.Released,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const updateMovieAvailabilityStatus = `-- name: UpdateMovieAvailabilityStatus :exec
UPDATE movies SET availability_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieAvailabilityStatusParams struct {
	AvailabilityStatus string `json:"availability_status"`
	ID                 int64  `json:"id"`
}

func (q *Queries) UpdateMovieAvailabilityStatus(ctx context.Context, arg UpdateMovieAvailabilityStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieAvailabilityStatus, arg.AvailabilityStatus, arg.ID)
	return err
}

const updateMovieReleaseDates = `-- name: UpdateMovieReleaseDates :exec
UPDATE movies SET
    release_date = ?,
    digital_release_date = ?,
    physical_release_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieReleaseDatesParams struct {
	ReleaseDate         sql.NullTime `json:"release_date"`
	DigitalReleaseDate  sql.NullTime `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime `json:"physical_release_date"`
	ID                  int64        `json:"id"`
}

func (q *Queries) UpdateMovieReleaseDates(ctx context.Context, arg UpdateMovieReleaseDatesParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleaseDates,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.ID,
	)
	return err
}

const updateMovieReleased = `-- name: UpdateMovieReleased :exec
UPDATE movies SET released = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieReleasedParams struct {
	Released int64 `json:"released"`
	ID       int64 `json:"id"`
}

func (q *Queries) UpdateMovieReleased(ctx context.Context, arg UpdateMovieReleasedParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleased, arg.Released, arg.ID)
	return err
}

const updateMovieStatus = `-- name: UpdateMovieStatus :exec
UPDATE movies SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMovieStatus(ctx context.Context, arg UpdateMovieStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatus, arg.Status, arg.ID)
	return err
}

const updateMoviesReleasedByDate = `-- name: UpdateMoviesReleasedByDate :execresult
UPDATE movies SET released = 1, updated_at = CURRENT_TIMESTAMP
WHERE released = 0 AND release_date IS NOT NULL AND release_date <= date('now')
`

// Availability queries
func (q *Queries) UpdateMoviesReleasedByDate(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMoviesReleasedByDate)
}
