// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const countMissingMovies = `-- name: CountMissingMovies :one
SELECT COUNT(*) FROM movies m
WHERE m.status IN ('missing', 'failed')
  AND m.monitored = 1
`

func (q *Queries) CountMissingMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMissingMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = 1
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFiles = `-- name: CountMovieFiles :one
SELECT COUNT(*) FROM movie_files WHERE movie_id = ?
`

func (q *Queries) CountMovieFiles(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFiles, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieUpgradeCandidates = `-- name: CountMovieUpgradeCandidates :one
SELECT COUNT(*) FROM movies m
WHERE m.status = 'upgradable'
  AND m.monitored = 1
`

func (q *Queries) CountMovieUpgradeCandidates(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieUpgradeCandidates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    title, sort_title, year, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, status,
    release_date, physical_release_date, theatrical_release_date,
    studio, tvdb_id, content_rating, added_by
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by
`

type CreateMovieParams struct {
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	AddedBy               sql.NullInt64  `json:"added_by"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.PhysicalReleaseDate,
		arg.TheatricalReleaseDate,
		arg.Studio,
		arg.TvdbID,
		arg.ContentRating,
		arg.AddedBy,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO movie_files (movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution, audio_channels, dynamic_range)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type CreateMovieFileParams struct {
	MovieID       int64          `json:"movie_id"`
	Path          string         `json:"path"`
	Size          int64          `json:"size"`
	Quality       sql.NullString `json:"quality"`
	QualityID     sql.NullInt64  `json:"quality_id"`
	VideoCodec    sql.NullString `json:"video_codec"`
	AudioCodec    sql.NullString `json:"audio_codec"`
	Resolution    sql.NullString `json:"resolution"`
	AudioChannels sql.NullString `json:"audio_channels"`
	DynamicRange  sql.NullString `json:"dynamic_range"`
}

func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFile,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.AudioChannels,
		arg.DynamicRange,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const createMovieFileWithImportInfo = `-- name: CreateMovieFileWithImportInfo :one
INSERT INTO movie_files (
    movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution,
    audio_channels, dynamic_range, original_path, original_filename, imported_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type CreateMovieFileWithImportInfoParams struct {
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	AudioChannels    sql.NullString `json:"audio_channels"`
	DynamicRange     sql.NullString `json:"dynamic_range"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
}

// Import-related movie file operations
func (q *Queries) CreateMovieFileWithImportInfo(ctx context.Context, arg CreateMovieFileWithImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFileWithImportInfo,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.AudioChannels,
		arg.DynamicRange,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
DELETE FROM movie_files WHERE id = ?
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieFilesByMovie = `-- name: DeleteMovieFilesByMovie :exec
DELETE FROM movie_files WHERE movie_id = ?
`

func (q *Queries) DeleteMovieFilesByMovie(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFilesByMovie, movieID)
	return err
}

const deleteMoviesByRootFolder = `-- name: DeleteMoviesByRootFolder :exec
DELETE FROM movies WHERE root_folder_id = ?
`

func (q *Queries) DeleteMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMoviesByRootFolder, rootFolderID)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE id = ? LIMIT 1
`

func (q *Queries) GetMovie(ctx context.Context, id int64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path sql.NullString) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const getMovieByTvdbID = `-- name: GetMovieByTvdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE tvdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTvdbID(ctx context.Context, tvdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTvdbID, tvdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM movie_files WHERE id = ? LIMIT 1
`

// Movie Files
func (q *Queries) GetMovieFile(ctx context.Context, id int64) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getMovieFileByOriginalPath = `-- name: GetMovieFileByOriginalPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM movie_files WHERE original_path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByOriginalPath(ctx context.Context, originalPath sql.NullString) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByOriginalPath, originalPath)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM movie_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByPath, path)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getMovieFilesWithImportInfo = `-- name: GetMovieFilesWithImportInfo :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM movie_files WHERE movie_id = ? ORDER BY imported_at DESC
`

func (q *Queries) GetMovieFilesWithImportInfo(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, getMovieFilesWithImportInfo, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieWithAddedBy = `-- name: GetMovieWithAddedBy :one
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date, m.studio, m.tvdb_id, m.content_rating, m.added_by, pu.username AS added_by_username FROM movies m
LEFT JOIN portal_users pu ON m.added_by = pu.id
WHERE m.id = ? LIMIT 1
`

type GetMovieWithAddedByRow struct {
	ID                    int64          `json:"id"`
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ActiveDownloadID      sql.NullString `json:"active_download_id"`
	StatusMessage         sql.NullString `json:"status_message"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	AddedAt               sql.NullTime   `json:"added_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	AddedBy               sql.NullInt64  `json:"added_by"`
	AddedByUsername       sql.NullString `json:"added_by_username"`
}

func (q *Queries) GetMovieWithAddedBy(ctx context.Context, id int64) (*GetMovieWithAddedByRow, error) {
	row := q.db.QueryRowContext(ctx, getMovieWithAddedBy, id)
	var i GetMovieWithAddedByRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
		&i.AddedByUsername,
	)
	return &i, err
}

const getMovieWithFileQuality = `-- name: GetMovieWithFileQuality :one
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date, m.studio, m.tvdb_id, m.content_rating, m.added_by, mf.id as file_id, mf.quality_id as current_quality_id
FROM movies m
LEFT JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.id = ?
LIMIT 1
`

type GetMovieWithFileQualityRow struct {
	ID                    int64          `json:"id"`
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ActiveDownloadID      sql.NullString `json:"active_download_id"`
	StatusMessage         sql.NullString `json:"status_message"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	AddedAt               sql.NullTime   `json:"added_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	AddedBy               sql.NullInt64  `json:"added_by"`
	FileID                sql.NullInt64  `json:"file_id"`
	CurrentQualityID      sql.NullInt64  `json:"current_quality_id"`
}

func (q *Queries) GetMovieWithFileQuality(ctx context.Context, id int64) (*GetMovieWithFileQualityRow, error) {
	row := q.db.QueryRowContext(ctx, getMovieWithFileQuality, id)
	var i GetMovieWithFileQualityRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
		&i.FileID,
		&i.CurrentQualityID,
	)
	return &i, err
}

const getMoviesInDateRange = `-- name: GetMoviesInDateRange :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies
WHERE (release_date BETWEEN ? AND ?)
   OR (physical_release_date BETWEEN ? AND ?)
   OR (theatrical_release_date BETWEEN ? AND ?)
ORDER BY COALESCE(release_date, physical_release_date, theatrical_release_date)
`

type GetMoviesInDateRangeParams struct {
	FromReleaseDate           sql.NullTime `json:"from_release_date"`
	ToReleaseDate             sql.NullTime `json:"to_release_date"`
	FromPhysicalReleaseDate   sql.NullTime `json:"from_physical_release_date"`
	ToPhysicalReleaseDate     sql.NullTime `json:"to_physical_release_date"`
	FromTheatricalReleaseDate sql.NullTime `json:"from_theatrical_release_date"`
	ToTheatricalReleaseDate   sql.NullTime `json:"to_theatrical_release_date"`
}

// Calendar queries
func (q *Queries) GetMoviesInDateRange(ctx context.Context, arg GetMoviesInDateRangeParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getMoviesInDateRange,
		arg.FromReleaseDate,
		arg.ToReleaseDate,
		arg.FromPhysicalReleaseDate,
		arg.ToPhysicalReleaseDate,
		arg.FromTheatricalReleaseDate,
		arg.ToTheatricalReleaseDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreleasedMoviesWithPastDate = `-- name: GetUnreleasedMoviesWithPastDate :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies
WHERE status = 'unreleased' AND (
    (release_date IS NOT NULL AND substr(release_date, 1, 10) <= date('now'))
    OR (physical_release_date IS NOT NULL AND substr(physical_release_date, 1, 10) <= date('now'))
    OR (theatrical_release_date IS NOT NULL AND date(substr(theatrical_release_date, 1, 10), '+90 days') <= date('now'))
)
`

func (q *Queries) GetUnreleasedMoviesWithPastDate(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getUnreleasedMoviesWithPastDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isOriginalPathImportedMovie = `-- name: IsOriginalPathImportedMovie :one
SELECT EXISTS(SELECT 1 FROM movie_files WHERE original_path = ?) AS imported
`

func (q *Queries) IsOriginalPathImportedMovie(ctx context.Context, originalPath sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, isOriginalPathImportedMovie, originalPath)
	var imported int64
	err := row.Scan(&imported)
	return imported, err
}

const listAllMovieFilePaths = `-- name: ListAllMovieFilePaths :many
SELECT path FROM movie_files
`

func (q *Queries) ListAllMovieFilePaths(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllMovieFilePaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadingMovies = `-- name: ListDownloadingMovies :many
SELECT id, active_download_id FROM movies
WHERE status = 'downloading' AND active_download_id IS NOT NULL
`

type ListDownloadingMoviesRow struct {
	ID               int64          `json:"id"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
}

func (q *Queries) ListDownloadingMovies(ctx context.Context) ([]*ListDownloadingMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDownloadingMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListDownloadingMoviesRow{}
	for rows.Next() {
		var i ListDownloadingMoviesRow
		if err := rows.Scan(&i.ID, &i.ActiveDownloadID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMissingMovies = `-- name: ListMissingMovies :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date, m.studio, m.tvdb_id, m.content_rating, m.added_by FROM movies m
WHERE m.status IN ('missing', 'failed')
  AND m.monitored = 1
ORDER BY m.release_date DESC
`

// Missing movies queries (status-based)
func (q *Queries) ListMissingMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMissingMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredMovies = `-- name: ListMonitoredMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFiles = `-- name: ListMovieFiles :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM movie_files WHERE movie_id = ? ORDER BY path
`

func (q *Queries) ListMovieFiles(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFiles, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFilesForRootFolder = `-- name: ListMovieFilesForRootFolder :many
SELECT mf.id as file_id, mf.path, mf.movie_id, m.status as movie_status
FROM movie_files mf
JOIN movies m ON mf.movie_id = m.id
WHERE m.root_folder_id = ?
  AND m.status IN ('available', 'upgradable')
`

type ListMovieFilesForRootFolderRow struct {
	FileID      int64  `json:"file_id"`
	Path        string `json:"path"`
	MovieID     int64  `json:"movie_id"`
	MovieStatus string `json:"movie_status"`
}

func (q *Queries) ListMovieFilesForRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*ListMovieFilesForRootFolderRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFilesForRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieFilesForRootFolderRow{}
	for rows.Next() {
		var i ListMovieFilesForRootFolderRow
		if err := rows.Scan(
			&i.FileID,
			&i.Path,
			&i.MovieID,
			&i.MovieStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieUpgradeCandidates = `-- name: ListMovieUpgradeCandidates :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date, m.studio, m.tvdb_id, m.content_rating, m.added_by, mf.quality_id as current_quality_id FROM movies m
JOIN movie_files mf ON mf.id = (
    SELECT id FROM movie_files WHERE movie_id = m.id ORDER BY id DESC LIMIT 1
)
WHERE m.status = 'upgradable'
  AND m.monitored = 1
ORDER BY m.release_date DESC
`

type ListMovieUpgradeCandidatesRow struct {
	ID                    int64          `json:"id"`
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ActiveDownloadID      sql.NullString `json:"active_download_id"`
	StatusMessage         sql.NullString `json:"status_message"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	AddedAt               sql.NullTime   `json:"added_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	AddedBy               sql.NullInt64  `json:"added_by"`
	CurrentQualityID      sql.NullInt64  `json:"current_quality_id"`
}

// Upgrade candidate queries (status-based)
func (q *Queries) ListMovieUpgradeCandidates(ctx context.Context) ([]*ListMovieUpgradeCandidatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieUpgradeCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieUpgradeCandidatesRow{}
	for rows.Next() {
		var i ListMovieUpgradeCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies ORDER BY sort_title
`

func (q *Queries) ListMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByRootFolder = `-- name: ListMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesPaginated = `-- name: ListMoviesPaginated :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListMoviesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListMoviesPaginated(ctx context.Context, arg ListMoviesPaginatedParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesWithFilesForProfile = `-- name: ListMoviesWithFilesForProfile :many
SELECT m.id, m.status, mf.id as file_id, mf.quality_id as current_quality_id
FROM movies m
JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.quality_profile_id = ?
  AND m.status IN ('available', 'upgradable')
  AND mf.quality_id IS NOT NULL
`

type ListMoviesWithFilesForProfileRow struct {
	ID               int64         `json:"id"`
	Status           string        `json:"status"`
	FileID           int64         `json:"file_id"`
	CurrentQualityID sql.NullInt64 `json:"current_quality_id"`
}

// Quality profile recalculation: find movies with files to evaluate against new cutoff
func (q *Queries) ListMoviesWithFilesForProfile(ctx context.Context, qualityProfileID sql.NullInt64) ([]*ListMoviesWithFilesForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesWithFilesForProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMoviesWithFilesForProfileRow{}
	for rows.Next() {
		var i ListMoviesWithFilesForProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedMoviesByRootFolder = `-- name: ListUnmatchedMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies
WHERE root_folder_id = ?
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpgradableMoviesWithQuality = `-- name: ListUpgradableMoviesWithQuality :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date, m.studio, m.tvdb_id, m.content_rating, m.added_by, mf.quality_id as current_quality_id
FROM movies m
JOIN movie_files mf ON mf.id = (
    SELECT id FROM movie_files WHERE movie_id = m.id ORDER BY id DESC LIMIT 1
)
WHERE m.status = 'upgradable' AND m.monitored = 1
ORDER BY m.release_date DESC
`

type ListUpgradableMoviesWithQualityRow struct {
	ID                    int64          `json:"id"`
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ActiveDownloadID      sql.NullString `json:"active_download_id"`
	StatusMessage         sql.NullString `json:"status_message"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	AddedAt               sql.NullTime   `json:"added_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	AddedBy               sql.NullInt64  `json:"added_by"`
	CurrentQualityID      sql.NullInt64  `json:"current_quality_id"`
}

// Upgradable movies with current file quality
func (q *Queries) ListUpgradableMoviesWithQuality(ctx context.Context) ([]*ListUpgradableMoviesWithQualityRow, error) {
	rows, err := q.db.QueryContext(ctx, listUpgradableMoviesWithQuality)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUpgradableMoviesWithQualityRow{}
	for rows.Next() {
		var i ListUpgradableMoviesWithQualityRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by FROM movies
WHERE title LIKE ?1 OR sort_title LIKE ?1
   OR REPLACE(title, '''', '') LIKE ?1
   OR REPLACE(sort_title, '''', '') LIKE ?1
ORDER BY sort_title
LIMIT ?3 OFFSET ?2
`

type SearchMoviesParams struct {
	SearchTerm string `json:"search_term"`
	Off        int64  `json:"off"`
	Lim        int64  `json:"lim"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, searchMovies, arg.SearchTerm, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
			&i.Studio,
			&i.TvdbID,
			&i.ContentRating,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = ?,
    sort_title = ?,
    year = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    status = ?,
    release_date = ?,
    physical_release_date = ?,
    theatrical_release_date = ?,
    studio = ?,
    tvdb_id = ?,
    content_rating = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, active_download_id, status_message, release_date, physical_release_date, added_at, updated_at, theatrical_release_date, studio, tvdb_id, content_rating, added_by
`

type UpdateMovieParams struct {
	Title                 string         `json:"title"`
	SortTitle             string         `json:"sort_title"`
	Year                  sql.NullInt64  `json:"year"`
	TmdbID                sql.NullInt64  `json:"tmdb_id"`
	ImdbID                sql.NullString `json:"imdb_id"`
	Overview              sql.NullString `json:"overview"`
	Runtime               sql.NullInt64  `json:"runtime"`
	Path                  sql.NullString `json:"path"`
	RootFolderID          sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID      sql.NullInt64  `json:"quality_profile_id"`
	Monitored             int64          `json:"monitored"`
	Status                string         `json:"status"`
	ReleaseDate           sql.NullTime   `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime   `json:"physical_release_date"`
	TheatricalReleaseDate sql.NullTime   `json:"theatrical_release_date"`
	Studio                sql.NullString `json:"studio"`
	TvdbID                sql.NullInt64  `json:"tvdb_id"`
	ContentRating         sql.NullString `json:"content_rating"`
	ID                    int64          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.PhysicalReleaseDate,
		arg.TheatricalReleaseDate,
		arg.Studio,
		arg.TvdbID,
		arg.ContentRating,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.ReleaseDate,
		&i.PhysicalReleaseDate,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.TheatricalReleaseDate,
		&i.Studio,
		&i.TvdbID,
		&i.ContentRating,
		&i.AddedBy,
	)
	return &i, err
}

const updateMovieFileImportInfo = `-- name: UpdateMovieFileImportInfo :one
UPDATE movie_files SET
    original_path = ?,
    original_filename = ?,
    imported_at = ?
WHERE id = ?
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type UpdateMovieFileImportInfoParams struct {
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovieFileImportInfo(ctx context.Context, arg UpdateMovieFileImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, updateMovieFileImportInfo,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
		arg.ID,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const updateMovieFileMediaInfo = `-- name: UpdateMovieFileMediaInfo :exec
UPDATE movie_files SET
    video_codec = ?,
    audio_codec = ?,
    resolution = ?
WHERE movie_id = ?
`

type UpdateMovieFileMediaInfoParams struct {
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
	MovieID    int64          `json:"movie_id"`
}

func (q *Queries) UpdateMovieFileMediaInfo(ctx context.Context, arg UpdateMovieFileMediaInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFileMediaInfo,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.MovieID,
	)
	return err
}

const updateMovieFilePath = `-- name: UpdateMovieFilePath :exec
UPDATE movie_files SET path = ? WHERE id = ?
`

type UpdateMovieFilePathParams struct {
	Path string `json:"path"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateMovieFilePath(ctx context.Context, arg UpdateMovieFilePathParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFilePath, arg.Path, arg.ID)
	return err
}

const updateMovieFileQualityID = `-- name: UpdateMovieFileQualityID :exec
UPDATE movie_files SET quality_id = ? WHERE id = ?
`

type UpdateMovieFileQualityIDParams struct {
	QualityID sql.NullInt64 `json:"quality_id"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateMovieFileQualityID(ctx context.Context, arg UpdateMovieFileQualityIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFileQualityID, arg.QualityID, arg.ID)
	return err
}

const updateMovieMonitored = `-- name: UpdateMovieMonitored :exec
UPDATE movies SET monitored = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateMovieMonitored(ctx context.Context, arg UpdateMovieMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieMonitored, arg.Monitored, arg.ID)
	return err
}

const updateMovieReleaseDates = `-- name: UpdateMovieReleaseDates :exec
UPDATE movies SET
    release_date = ?,
    physical_release_date = ?,
    theatrical_release_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieReleaseDatesParams struct {
	ReleaseDate           sql.NullTime `json:"release_date"`
	PhysicalReleaseDate   sql.NullTime `json:"physical_release_date"`
	TheatricalReleaseDate sql.NullTime `json:"theatrical_release_date"`
	ID                    int64        `json:"id"`
}

func (q *Queries) UpdateMovieReleaseDates(ctx context.Context, arg UpdateMovieReleaseDatesParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleaseDates,
		arg.ReleaseDate,
		arg.PhysicalReleaseDate,
		arg.TheatricalReleaseDate,
		arg.ID,
	)
	return err
}

const updateMovieStatus = `-- name: UpdateMovieStatus :exec
UPDATE movies SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMovieStatus(ctx context.Context, arg UpdateMovieStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatus, arg.Status, arg.ID)
	return err
}

const updateMovieStatusWithDetails = `-- name: UpdateMovieStatusWithDetails :exec
UPDATE movies SET
    status = ?,
    active_download_id = ?,
    status_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieStatusWithDetailsParams struct {
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovieStatusWithDetails(ctx context.Context, arg UpdateMovieStatusWithDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatusWithDetails,
		arg.Status,
		arg.ActiveDownloadID,
		arg.StatusMessage,
		arg.ID,
	)
	return err
}

const updateMoviesMonitoredByIDs = `-- name: UpdateMoviesMonitoredByIDs :exec
UPDATE movies SET monitored = ?, updated_at = CURRENT_TIMESTAMP WHERE id IN (/*SLICE:ids*/?)
`

type UpdateMoviesMonitoredByIDsParams struct {
	Monitored int64   `json:"monitored"`
	Ids       []int64 `json:"ids"`
}

func (q *Queries) UpdateMoviesMonitoredByIDs(ctx context.Context, arg UpdateMoviesMonitoredByIDsParams) error {
	query := updateMoviesMonitoredByIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateMoviesToUnreleased = `-- name: UpdateMoviesToUnreleased :execresult
UPDATE movies SET status = 'unreleased', updated_at = CURRENT_TIMESTAMP
WHERE status = 'missing'
    AND (release_date IS NULL OR substr(release_date, 1, 10) > date('now'))
    AND (physical_release_date IS NULL OR substr(physical_release_date, 1, 10) > date('now'))
    AND (theatrical_release_date IS NULL OR date(substr(theatrical_release_date, 1, 10), '+90 days') > date('now'))
`

func (q *Queries) UpdateMoviesToUnreleased(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMoviesToUnreleased)
}

const updateUnreleasedMoviesToMissing = `-- name: UpdateUnreleasedMoviesToMissing :execresult

UPDATE movies SET status = 'missing', updated_at = CURRENT_TIMESTAMP
WHERE status = 'unreleased' AND (
    (release_date IS NOT NULL AND substr(release_date, 1, 10) <= date('now'))
    OR (physical_release_date IS NOT NULL AND substr(physical_release_date, 1, 10) <= date('now'))
    OR (theatrical_release_date IS NOT NULL AND date(substr(theatrical_release_date, 1, 10), '+90 days') <= date('now'))
)
`

// Status refresh queries
// Note: substr(col, 1, 10) is required because the Go SQLite driver (modernc.org/sqlite)
// stores time.Time in RFC3339 format with timezone offset (e.g. '2026-02-10T00:00:00-07:00').
// SQLite's date() function cannot parse this format (returns NULL), and raw string comparison
// fails on same-day dates since 'T' extends past the date-only string from date('now').
func (q *Queries) UpdateUnreleasedMoviesToMissing(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUnreleasedMoviesToMissing)
}
