// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countMissingMovies = `-- name: CountMissingMovies :one
SELECT COUNT(*) FROM movies m
LEFT JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.released = 1 AND m.monitored = 1 AND mf.id IS NULL
`

func (q *Queries) CountMissingMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMissingMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = 1
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFiles = `-- name: CountMovieFiles :one
SELECT COUNT(*) FROM movie_files WHERE movie_id = ?
`

func (q *Queries) CountMovieFiles(ctx context.Context, movieID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFiles, movieID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieUpgradeCandidates = `-- name: CountMovieUpgradeCandidates :one
SELECT COUNT(*) FROM movies m
JOIN movie_files mf ON m.id = mf.movie_id
JOIN quality_profiles qp ON m.quality_profile_id = qp.id
WHERE m.monitored = 1
  AND m.released = 1
  AND mf.quality_id IS NOT NULL
  AND mf.quality_id < qp.cutoff
`

func (q *Queries) CountMovieUpgradeCandidates(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieUpgradeCandidates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    title, sort_title, year, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, status,
    release_date, digital_release_date, physical_release_date, released
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status
`

type CreateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.Released,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const createMovieFile = `-- name: CreateMovieFile :one
INSERT INTO movie_files (movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type CreateMovieFileParams struct {
	MovieID    int64          `json:"movie_id"`
	Path       string         `json:"path"`
	Size       int64          `json:"size"`
	Quality    sql.NullString `json:"quality"`
	QualityID  sql.NullInt64  `json:"quality_id"`
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
}

func (q *Queries) CreateMovieFile(ctx context.Context, arg CreateMovieFileParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFile,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const createMovieFileWithImportInfo = `-- name: CreateMovieFileWithImportInfo :one
INSERT INTO movie_files (
    movie_id, path, size, quality, quality_id, video_codec, audio_codec, resolution,
    original_path, original_filename, imported_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type CreateMovieFileWithImportInfoParams struct {
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
}

// Import-related movie file operations
func (q *Queries) CreateMovieFileWithImportInfo(ctx context.Context, arg CreateMovieFileWithImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, createMovieFileWithImportInfo,
		arg.MovieID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = ?
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, id)
	return err
}

const deleteMovieFile = `-- name: DeleteMovieFile :exec
DELETE FROM movie_files WHERE id = ?
`

func (q *Queries) DeleteMovieFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFile, id)
	return err
}

const deleteMovieFilesByMovie = `-- name: DeleteMovieFilesByMovie :exec
DELETE FROM movie_files WHERE movie_id = ?
`

func (q *Queries) DeleteMovieFilesByMovie(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFilesByMovie, movieID)
	return err
}

const deleteMoviesByRootFolder = `-- name: DeleteMoviesByRootFolder :exec
DELETE FROM movies WHERE root_folder_id = ?
`

func (q *Queries) DeleteMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMoviesByRootFolder, rootFolderID)
	return err
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE id = ? LIMIT 1
`

func (q *Queries) GetMovie(ctx context.Context, id int64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieByPath = `-- name: GetMovieByPath :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieByPath(ctx context.Context, path sql.NullString) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByPath, path)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieByTmdbID = `-- name: GetMovieByTmdbID :one
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetMovieByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByTmdbID, tmdbID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const getMovieFile = `-- name: GetMovieFile :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE id = ? LIMIT 1
`

// Movie Files
func (q *Queries) GetMovieFile(ctx context.Context, id int64) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFile, id)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const getMovieFileByPath = `-- name: GetMovieFileByPath :one
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetMovieFileByPath(ctx context.Context, path string) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, getMovieFileByPath, path)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const getMovieFilesWithImportInfo = `-- name: GetMovieFilesWithImportInfo :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE movie_id = ? ORDER BY imported_at DESC
`

func (q *Queries) GetMovieFilesWithImportInfo(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, getMovieFilesWithImportInfo, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieWithFileQuality = `-- name: GetMovieWithFileQuality :one
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.added_at, m.updated_at, m.release_date, m.digital_release_date, m.physical_release_date, m.released, m.availability_status, mf.id as file_id, mf.quality_id as current_quality_id
FROM movies m
LEFT JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.id = ?
LIMIT 1
`

type GetMovieWithFileQualityRow struct {
	ID                  int64          `json:"id"`
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	AddedAt             sql.NullTime   `json:"added_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
	AvailabilityStatus  string         `json:"availability_status"`
	FileID              sql.NullInt64  `json:"file_id"`
	CurrentQualityID    sql.NullInt64  `json:"current_quality_id"`
}

func (q *Queries) GetMovieWithFileQuality(ctx context.Context, id int64) (*GetMovieWithFileQualityRow, error) {
	row := q.db.QueryRowContext(ctx, getMovieWithFileQuality, id)
	var i GetMovieWithFileQualityRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
		&i.FileID,
		&i.CurrentQualityID,
	)
	return &i, err
}

const getMoviesInDateRange = `-- name: GetMoviesInDateRange :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE (release_date BETWEEN ? AND ?)
   OR (digital_release_date BETWEEN ? AND ?)
   OR (physical_release_date BETWEEN ? AND ?)
ORDER BY COALESCE(release_date, digital_release_date, physical_release_date)
`

type GetMoviesInDateRangeParams struct {
	FromReleaseDate         sql.NullTime `json:"from_release_date"`
	ToReleaseDate           sql.NullTime `json:"to_release_date"`
	FromDigitalReleaseDate  sql.NullTime `json:"from_digital_release_date"`
	ToDigitalReleaseDate    sql.NullTime `json:"to_digital_release_date"`
	FromPhysicalReleaseDate sql.NullTime `json:"from_physical_release_date"`
	ToPhysicalReleaseDate   sql.NullTime `json:"to_physical_release_date"`
}

// Calendar queries
func (q *Queries) GetMoviesInDateRange(ctx context.Context, arg GetMoviesInDateRangeParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getMoviesInDateRange,
		arg.FromReleaseDate,
		arg.ToReleaseDate,
		arg.FromDigitalReleaseDate,
		arg.ToDigitalReleaseDate,
		arg.FromPhysicalReleaseDate,
		arg.ToPhysicalReleaseDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreleasedMoviesWithPastDate = `-- name: GetUnreleasedMoviesWithPastDate :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE released = 0 AND release_date IS NOT NULL AND release_date <= date('now')
`

func (q *Queries) GetUnreleasedMoviesWithPastDate(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, getUnreleasedMoviesWithPastDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMissingMovies = `-- name: ListMissingMovies :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.added_at, m.updated_at, m.release_date, m.digital_release_date, m.physical_release_date, m.released, m.availability_status FROM movies m
LEFT JOIN movie_files mf ON m.id = mf.movie_id
WHERE m.released = 1 AND m.monitored = 1 AND mf.id IS NULL
ORDER BY m.release_date DESC
`

// Missing movies queries
func (q *Queries) ListMissingMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMissingMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredMovies = `-- name: ListMonitoredMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFiles = `-- name: ListMovieFiles :many
SELECT id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id FROM movie_files WHERE movie_id = ? ORDER BY path
`

func (q *Queries) ListMovieFiles(ctx context.Context, movieID int64) ([]*MovieFile, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFiles, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MovieFile{}
	for rows.Next() {
		var i MovieFile
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieUpgradeCandidates = `-- name: ListMovieUpgradeCandidates :many
SELECT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.added_at, m.updated_at, m.release_date, m.digital_release_date, m.physical_release_date, m.released, m.availability_status, mf.id as file_id, mf.quality_id as current_quality_id, qp.cutoff
FROM movies m
JOIN movie_files mf ON m.id = mf.movie_id
JOIN quality_profiles qp ON m.quality_profile_id = qp.id
WHERE m.monitored = 1
  AND m.released = 1
  AND mf.quality_id IS NOT NULL
  AND mf.quality_id < qp.cutoff
ORDER BY m.release_date DESC
`

type ListMovieUpgradeCandidatesRow struct {
	ID                  int64          `json:"id"`
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	AddedAt             sql.NullTime   `json:"added_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
	AvailabilityStatus  string         `json:"availability_status"`
	FileID              int64          `json:"file_id"`
	CurrentQualityID    sql.NullInt64  `json:"current_quality_id"`
	Cutoff              int64          `json:"cutoff"`
}

// Upgrade candidate queries (movies with files below quality cutoff)
func (q *Queries) ListMovieUpgradeCandidates(ctx context.Context) ([]*ListMovieUpgradeCandidatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieUpgradeCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieUpgradeCandidatesRow{}
	for rows.Next() {
		var i ListMovieUpgradeCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
			&i.FileID,
			&i.CurrentQualityID,
			&i.Cutoff,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovies = `-- name: ListMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies ORDER BY sort_title
`

func (q *Queries) ListMovies(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesByRootFolder = `-- name: ListMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesPaginated = `-- name: ListMoviesPaginated :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListMoviesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListMoviesPaginated(ctx context.Context, arg ListMoviesPaginatedParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedMoviesByRootFolder = `-- name: ListUnmatchedMoviesByRootFolder :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE root_folder_id = ?
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedMoviesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedMoviesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovies = `-- name: SearchMovies :many
SELECT id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status FROM movies
WHERE title LIKE ? OR sort_title LIKE ?
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type SearchMoviesParams struct {
	Title     string `json:"title"`
	SortTitle string `json:"sort_title"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) SearchMovies(ctx context.Context, arg SearchMoviesParams) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, searchMovies,
		arg.Title,
		arg.SortTitle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.DigitalReleaseDate,
			&i.PhysicalReleaseDate,
			&i.Released,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAllMoviesAvailabilityStatus = `-- name: UpdateAllMoviesAvailabilityStatus :execresult
UPDATE movies SET
    availability_status = CASE WHEN released = 1 THEN 'Available' ELSE 'Unreleased' END,
    updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) UpdateAllMoviesAvailabilityStatus(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateAllMoviesAvailabilityStatus)
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE movies SET
    title = ?,
    sort_title = ?,
    year = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    status = ?,
    release_date = ?,
    digital_release_date = ?,
    physical_release_date = ?,
    released = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, status, added_at, updated_at, release_date, digital_release_date, physical_release_date, released, availability_status
`

type UpdateMovieParams struct {
	Title               string         `json:"title"`
	SortTitle           string         `json:"sort_title"`
	Year                sql.NullInt64  `json:"year"`
	TmdbID              sql.NullInt64  `json:"tmdb_id"`
	ImdbID              sql.NullString `json:"imdb_id"`
	Overview            sql.NullString `json:"overview"`
	Runtime             sql.NullInt64  `json:"runtime"`
	Path                sql.NullString `json:"path"`
	RootFolderID        sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID    sql.NullInt64  `json:"quality_profile_id"`
	Monitored           int64          `json:"monitored"`
	Status              string         `json:"status"`
	ReleaseDate         sql.NullTime   `json:"release_date"`
	DigitalReleaseDate  sql.NullTime   `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime   `json:"physical_release_date"`
	Released            int64          `json:"released"`
	ID                  int64          `json:"id"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (*Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.Released,
		arg.ID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.ReleaseDate,
		&i.DigitalReleaseDate,
		&i.PhysicalReleaseDate,
		&i.Released,
		&i.AvailabilityStatus,
	)
	return &i, err
}

const updateMovieAvailabilityStatus = `-- name: UpdateMovieAvailabilityStatus :exec
UPDATE movies SET availability_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieAvailabilityStatusParams struct {
	AvailabilityStatus string `json:"availability_status"`
	ID                 int64  `json:"id"`
}

func (q *Queries) UpdateMovieAvailabilityStatus(ctx context.Context, arg UpdateMovieAvailabilityStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieAvailabilityStatus, arg.AvailabilityStatus, arg.ID)
	return err
}

const updateMovieFileImportInfo = `-- name: UpdateMovieFileImportInfo :one
UPDATE movie_files SET
    original_path = ?,
    original_filename = ?,
    imported_at = ?
WHERE id = ?
RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type UpdateMovieFileImportInfoParams struct {
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateMovieFileImportInfo(ctx context.Context, arg UpdateMovieFileImportInfoParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, updateMovieFileImportInfo,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
		arg.ID,
	)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const updateMovieFilePath = `-- name: UpdateMovieFilePath :exec
UPDATE movie_files SET path = ? WHERE id = ?
`

type UpdateMovieFilePathParams struct {
	Path string `json:"path"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateMovieFilePath(ctx context.Context, arg UpdateMovieFilePathParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFilePath, arg.Path, arg.ID)
	return err
}

const updateMovieFileQualityID = `-- name: UpdateMovieFileQualityID :exec
UPDATE movie_files SET quality_id = ? WHERE id = ?
`

type UpdateMovieFileQualityIDParams struct {
	QualityID sql.NullInt64 `json:"quality_id"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateMovieFileQualityID(ctx context.Context, arg UpdateMovieFileQualityIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieFileQualityID, arg.QualityID, arg.ID)
	return err
}

const updateMovieReleaseDates = `-- name: UpdateMovieReleaseDates :exec
UPDATE movies SET
    release_date = ?,
    digital_release_date = ?,
    physical_release_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateMovieReleaseDatesParams struct {
	ReleaseDate         sql.NullTime `json:"release_date"`
	DigitalReleaseDate  sql.NullTime `json:"digital_release_date"`
	PhysicalReleaseDate sql.NullTime `json:"physical_release_date"`
	ID                  int64        `json:"id"`
}

func (q *Queries) UpdateMovieReleaseDates(ctx context.Context, arg UpdateMovieReleaseDatesParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleaseDates,
		arg.ReleaseDate,
		arg.DigitalReleaseDate,
		arg.PhysicalReleaseDate,
		arg.ID,
	)
	return err
}

const updateMovieReleased = `-- name: UpdateMovieReleased :exec
UPDATE movies SET released = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieReleasedParams struct {
	Released int64 `json:"released"`
	ID       int64 `json:"id"`
}

func (q *Queries) UpdateMovieReleased(ctx context.Context, arg UpdateMovieReleasedParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieReleased, arg.Released, arg.ID)
	return err
}

const updateMovieStatus = `-- name: UpdateMovieStatus :exec
UPDATE movies SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateMovieStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateMovieStatus(ctx context.Context, arg UpdateMovieStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieStatus, arg.Status, arg.ID)
	return err
}

const updateMoviesReleasedByDate = `-- name: UpdateMoviesReleasedByDate :execresult
UPDATE movies SET released = 1, updated_at = CURRENT_TIMESTAMP
WHERE released = 0 AND release_date IS NOT NULL AND release_date <= date('now')
`

// Availability queries
func (q *Queries) UpdateMoviesReleasedByDate(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMoviesReleasedByDate)
}
