// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: series.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countEpisodeFilesBySeason = `-- name: CountEpisodeFilesBySeason :one
SELECT COUNT(*) FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ? AND e.season_number = ?
`

type CountEpisodeFilesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) CountEpisodeFilesBySeason(ctx context.Context, arg CountEpisodeFilesBySeasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesBySeason, arg.SeriesID, arg.SeasonNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeFilesBySeries = `-- name: CountEpisodeFilesBySeries :one
SELECT COUNT(*) FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ?
`

func (q *Queries) CountEpisodeFilesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeason = `-- name: CountEpisodesBySeason :one
SELECT COUNT(*) FROM episodes WHERE series_id = ? AND season_number = ?
`

type CountEpisodesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) CountEpisodesBySeason(ctx context.Context, arg CountEpisodesBySeasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodesBySeason, arg.SeriesID, arg.SeasonNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeries = `-- name: CountEpisodesBySeries :one
SELECT COUNT(*) FROM episodes WHERE series_id = ?
`

func (q *Queries) CountEpisodesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) FROM series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    series_id, season_number, episode_number, title, overview, air_date, monitored
) VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored
`

type CreateEpisodeParams struct {
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, createEpisode,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
	)
	return &i, err
}

const createEpisodeFile = `-- name: CreateEpisodeFile :one
INSERT INTO episode_files (episode_id, path, size, quality, video_codec, audio_codec, resolution)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at
`

type CreateEpisodeFileParams struct {
	EpisodeID  int64          `json:"episode_id"`
	Path       string         `json:"path"`
	Size       int64          `json:"size"`
	Quality    sql.NullString `json:"quality"`
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
}

func (q *Queries) CreateEpisodeFile(ctx context.Context, arg CreateEpisodeFileParams) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, createEpisodeFile,
		arg.EpisodeID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
	)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const createSeason = `-- name: CreateSeason :one
INSERT INTO seasons (series_id, season_number, monitored)
VALUES (?, ?, ?)
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type CreateSeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
	Monitored    int64 `json:"monitored"`
}

func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, createSeason, arg.SeriesID, arg.SeasonNumber, arg.Monitored)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (
    title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, season_folder, status, network
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network
`

type CreateSeriesParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	SeasonFolder     int64          `json:"season_folder"`
	Status           string         `json:"status"`
	Network          sql.NullString `json:"network"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TvdbID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.SeasonFolder,
		arg.Status,
		arg.Network,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Network,
	)
	return &i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episodes WHERE id = ?
`

func (q *Queries) DeleteEpisode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode, id)
	return err
}

const deleteEpisodeFile = `-- name: DeleteEpisodeFile :exec
DELETE FROM episode_files WHERE id = ?
`

func (q *Queries) DeleteEpisodeFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeFile, id)
	return err
}

const deleteEpisodeFilesByEpisode = `-- name: DeleteEpisodeFilesByEpisode :exec
DELETE FROM episode_files WHERE episode_id = ?
`

func (q *Queries) DeleteEpisodeFilesByEpisode(ctx context.Context, episodeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeFilesByEpisode, episodeID)
	return err
}

const deleteEpisodesBySeries = `-- name: DeleteEpisodesBySeries :exec
DELETE FROM episodes WHERE series_id = ?
`

func (q *Queries) DeleteEpisodesBySeries(ctx context.Context, seriesID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodesBySeries, seriesID)
	return err
}

const deleteSeasonsBySeries = `-- name: DeleteSeasonsBySeries :exec
DELETE FROM seasons WHERE series_id = ?
`

func (q *Queries) DeleteSeasonsBySeries(ctx context.Context, seriesID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSeasonsBySeries, seriesID)
	return err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE FROM series WHERE id = ?
`

func (q *Queries) DeleteSeries(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSeries, id)
	return err
}

const deleteSeriesByRootFolder = `-- name: DeleteSeriesByRootFolder :exec
DELETE FROM series WHERE root_folder_id = ?
`

func (q *Queries) DeleteSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteSeriesByRootFolder, rootFolderID)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored FROM episodes WHERE id = ? LIMIT 1
`

// Episodes
func (q *Queries) GetEpisode(ctx context.Context, id int64) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
	)
	return &i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored FROM episodes
WHERE series_id = ? AND season_number = ? AND episode_number = ?
LIMIT 1
`

type GetEpisodeByNumberParams struct {
	SeriesID      int64 `json:"series_id"`
	SeasonNumber  int64 `json:"season_number"`
	EpisodeNumber int64 `json:"episode_number"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeByNumber, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
	)
	return &i, err
}

const getEpisodeFile = `-- name: GetEpisodeFile :one
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM episode_files WHERE id = ? LIMIT 1
`

// Episode Files
func (q *Queries) GetEpisodeFile(ctx context.Context, id int64) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeFile, id)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const getEpisodeFileByPath = `-- name: GetEpisodeFileByPath :one
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM episode_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetEpisodeFileByPath(ctx context.Context, path string) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeFileByPath, path)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
	)
	return &i, err
}

const getEpisodesInDateRange = `-- name: GetEpisodesInDateRange :many
SELECT
    e.id,
    e.series_id,
    e.season_number,
    e.episode_number,
    e.title,
    e.overview,
    e.air_date,
    e.monitored,
    s.title as series_title,
    s.network,
    s.tmdb_id as series_tmdb_id
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE e.air_date BETWEEN ? AND ?
ORDER BY e.air_date, s.title, e.season_number, e.episode_number
`

type GetEpisodesInDateRangeParams struct {
	FromAirDate sql.NullTime `json:"from_air_date"`
	ToAirDate   sql.NullTime `json:"to_air_date"`
}

type GetEpisodesInDateRangeRow struct {
	ID            int64          `json:"id"`
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
	SeriesTitle   string         `json:"series_title"`
	Network       sql.NullString `json:"network"`
	SeriesTmdbID  sql.NullInt64  `json:"series_tmdb_id"`
}

// Calendar queries
func (q *Queries) GetEpisodesInDateRange(ctx context.Context, arg GetEpisodesInDateRangeParams) ([]*GetEpisodesInDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodesInDateRange, arg.FromAirDate, arg.ToAirDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEpisodesInDateRangeRow{}
	for rows.Next() {
		var i GetEpisodesInDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.SeriesTitle,
			&i.Network,
			&i.SeriesTmdbID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE id = ? LIMIT 1
`

// Seasons
func (q *Queries) GetSeason(ctx context.Context, id int64) (*Season, error) {
	row := q.db.QueryRowContext(ctx, getSeason, id)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const getSeasonByNumber = `-- name: GetSeasonByNumber :one
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE series_id = ? AND season_number = ? LIMIT 1
`

type GetSeasonByNumberParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) GetSeasonByNumber(ctx context.Context, arg GetSeasonByNumberParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, getSeasonByNumber, arg.SeriesID, arg.SeasonNumber)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const getSeries = `-- name: GetSeries :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series WHERE id = ? LIMIT 1
`

func (q *Queries) GetSeries(ctx context.Context, id int64) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Network,
	)
	return &i, err
}

const getSeriesByPath = `-- name: GetSeriesByPath :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series WHERE path = ? LIMIT 1
`

func (q *Queries) GetSeriesByPath(ctx context.Context, path sql.NullString) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByPath, path)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Network,
	)
	return &i, err
}

const getSeriesByTvdbID = `-- name: GetSeriesByTvdbID :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series WHERE tvdb_id = ? LIMIT 1
`

func (q *Queries) GetSeriesByTvdbID(ctx context.Context, tvdbID sql.NullInt64) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByTvdbID, tvdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Network,
	)
	return &i, err
}

const listEpisodeFilesByEpisode = `-- name: ListEpisodeFilesByEpisode :many
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at FROM episode_files WHERE episode_id = ? ORDER BY path
`

func (q *Queries) ListEpisodeFilesByEpisode(ctx context.Context, episodeID int64) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesByEpisode, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesBySeason = `-- name: ListEpisodeFilesBySeason :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ? AND e.season_number = ?
ORDER BY e.episode_number
`

type ListEpisodeFilesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) ListEpisodeFilesBySeason(ctx context.Context, arg ListEpisodeFilesBySeasonParams) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesBySeason, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesBySeries = `-- name: ListEpisodeFilesBySeries :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ?
ORDER BY e.season_number, e.episode_number
`

func (q *Queries) ListEpisodeFilesBySeries(ctx context.Context, seriesID int64) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeason = `-- name: ListEpisodesBySeason :many
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored FROM episodes WHERE series_id = ? AND season_number = ? ORDER BY episode_number
`

type ListEpisodesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) ListEpisodesBySeason(ctx context.Context, arg ListEpisodesBySeasonParams) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodesBySeason, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeries = `-- name: ListEpisodesBySeries :many
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored FROM episodes WHERE series_id = ? ORDER BY season_number, episode_number
`

func (q *Queries) ListEpisodesBySeries(ctx context.Context, seriesID int64) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredSeries = `-- name: ListMonitoredSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredSeries(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeasonsBySeries = `-- name: ListSeasonsBySeries :many
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE series_id = ? ORDER BY season_number
`

func (q *Queries) ListSeasonsBySeries(ctx context.Context, seriesID int64) ([]*Season, error) {
	rows, err := q.db.QueryContext(ctx, listSeasonsBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Season{}
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.Monitored,
			&i.Overview,
			&i.PosterUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series ORDER BY sort_title
`

func (q *Queries) ListSeries(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByRootFolder = `-- name: ListSeriesByRootFolder :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesPaginated = `-- name: ListSeriesPaginated :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListSeriesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSeriesPaginated(ctx context.Context, arg ListSeriesPaginatedParams) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedSeriesByRootFolder = `-- name: ListUnmatchedSeriesByRootFolder :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series
WHERE root_folder_id = ?
  AND (tvdb_id IS NULL OR tvdb_id = 0)
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedSeriesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSeries = `-- name: SearchSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network FROM series
WHERE title LIKE ? OR sort_title LIKE ?
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type SearchSeriesParams struct {
	Title     string `json:"title"`
	SortTitle string `json:"sort_title"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) SearchSeries(ctx context.Context, arg SearchSeriesParams) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, searchSeries,
		arg.Title,
		arg.SortTitle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.Status,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.Network,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes SET
    title = ?,
    overview = ?,
    air_date = ?,
    monitored = ?
WHERE id = ?
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored
`

type UpdateEpisodeParams struct {
	Title     sql.NullString `json:"title"`
	Overview  sql.NullString `json:"overview"`
	AirDate   sql.NullTime   `json:"air_date"`
	Monitored int64          `json:"monitored"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, updateEpisode,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
		arg.ID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
	)
	return &i, err
}

const updateSeason = `-- name: UpdateSeason :one
UPDATE seasons SET monitored = ? WHERE id = ? RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpdateSeasonParams struct {
	Monitored int64 `json:"monitored"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateSeason(ctx context.Context, arg UpdateSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, updateSeason, arg.Monitored, arg.ID)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const updateSeasonMetadata = `-- name: UpdateSeasonMetadata :one
UPDATE seasons SET
    overview = ?,
    poster_url = ?
WHERE id = ?
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpdateSeasonMetadataParams struct {
	Overview  sql.NullString `json:"overview"`
	PosterUrl sql.NullString `json:"poster_url"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateSeasonMetadata(ctx context.Context, arg UpdateSeasonMetadataParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, updateSeasonMetadata, arg.Overview, arg.PosterUrl, arg.ID)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series SET
    title = ?,
    sort_title = ?,
    year = ?,
    tvdb_id = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    season_folder = ?,
    status = ?,
    network = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, status, added_at, updated_at, network
`

type UpdateSeriesParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	SeasonFolder     int64          `json:"season_folder"`
	Status           string         `json:"status"`
	Network          sql.NullString `json:"network"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, updateSeries,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TvdbID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.SeasonFolder,
		arg.Status,
		arg.Network,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.Status,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.Network,
	)
	return &i, err
}

const updateSeriesNetwork = `-- name: UpdateSeriesNetwork :exec
UPDATE series SET network = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateSeriesNetworkParams struct {
	Network sql.NullString `json:"network"`
	ID      int64          `json:"id"`
}

func (q *Queries) UpdateSeriesNetwork(ctx context.Context, arg UpdateSeriesNetworkParams) error {
	_, err := q.db.ExecContext(ctx, updateSeriesNetwork, arg.Network, arg.ID)
	return err
}

const updateSeriesStatus = `-- name: UpdateSeriesStatus :exec
UPDATE series SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateSeriesStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateSeriesStatus(ctx context.Context, arg UpdateSeriesStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSeriesStatus, arg.Status, arg.ID)
	return err
}

const upsertEpisode = `-- name: UpsertEpisode :one
INSERT INTO episodes (series_id, season_number, episode_number, title, overview, air_date, monitored)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(series_id, season_number, episode_number) DO UPDATE SET
    title = COALESCE(excluded.title, episodes.title),
    overview = COALESCE(excluded.overview, episodes.overview),
    air_date = COALESCE(excluded.air_date, episodes.air_date)
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored
`

type UpsertEpisodeParams struct {
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, upsertEpisode,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
	)
	return &i, err
}

const upsertSeason = `-- name: UpsertSeason :one
INSERT INTO seasons (series_id, season_number, monitored, overview, poster_url)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(series_id, season_number) DO UPDATE SET
    overview = COALESCE(excluded.overview, seasons.overview),
    poster_url = COALESCE(excluded.poster_url, seasons.poster_url)
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpsertSeasonParams struct {
	SeriesID     int64          `json:"series_id"`
	SeasonNumber int64          `json:"season_number"`
	Monitored    int64          `json:"monitored"`
	Overview     sql.NullString `json:"overview"`
	PosterUrl    sql.NullString `json:"poster_url"`
}

func (q *Queries) UpsertSeason(ctx context.Context, arg UpsertSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, upsertSeason,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.Monitored,
		arg.Overview,
		arg.PosterUrl,
	)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}
