// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: series.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const countEpisodeFiles = `-- name: CountEpisodeFiles :one
SELECT COUNT(*) FROM episode_files WHERE episode_id = ?
`

func (q *Queries) CountEpisodeFiles(ctx context.Context, episodeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFiles, episodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeFilesBySeason = `-- name: CountEpisodeFilesBySeason :one
SELECT COUNT(*) FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ? AND e.season_number = ?
`

type CountEpisodeFilesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) CountEpisodeFilesBySeason(ctx context.Context, arg CountEpisodeFilesBySeasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesBySeason, arg.SeriesID, arg.SeasonNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeFilesBySeries = `-- name: CountEpisodeFilesBySeries :one
SELECT COUNT(*) FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ? AND e.season_number > 0
`

func (q *Queries) CountEpisodeFilesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeUpgradeCandidates = `-- name: CountEpisodeUpgradeCandidates :one
SELECT COUNT(*) FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.status = 'upgradable'
  AND e.monitored = 1
  AND s.monitored = 1
  AND sea.monitored = 1
`

func (q *Queries) CountEpisodeUpgradeCandidates(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeUpgradeCandidates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeason = `-- name: CountEpisodesBySeason :one
SELECT COUNT(*) FROM episodes WHERE series_id = ? AND season_number = ?
`

type CountEpisodesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) CountEpisodesBySeason(ctx context.Context, arg CountEpisodesBySeasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodesBySeason, arg.SeriesID, arg.SeasonNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeries = `-- name: CountEpisodesBySeries :one
SELECT COUNT(*) FROM episodes WHERE series_id = ? AND season_number > 0
`

func (q *Queries) CountEpisodesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMissingEpisodes = `-- name: CountMissingEpisodes :one
SELECT COUNT(*) FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.status IN ('missing', 'failed')
  AND s.monitored = 1
  AND sea.monitored = 1
  AND e.monitored = 1
`

func (q *Queries) CountMissingEpisodes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMissingEpisodes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMissingEpisodesBySeasons = `-- name: CountMissingEpisodesBySeasons :one
SELECT COUNT(*) FROM episodes e
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.series_id = ?
  AND e.season_number IN (/*SLICE:seasonNumbers*/?)
  AND e.status IN ('missing', 'failed')
  AND sea.monitored = 1
  AND e.monitored = 1
`

type CountMissingEpisodesBySeasonsParams struct {
	SeriesID      int64   `json:"series_id"`
	SeasonNumbers []int64 `json:"seasonNumbers"`
}

func (q *Queries) CountMissingEpisodesBySeasons(ctx context.Context, arg CountMissingEpisodesBySeasonsParams) (int64, error) {
	query := countMissingEpisodesBySeasons
	var queryParams []interface{}
	queryParams = append(queryParams, arg.SeriesID)
	if len(arg.SeasonNumbers) > 0 {
		for _, v := range arg.SeasonNumbers {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:seasonNumbers*/?", strings.Repeat(",?", len(arg.SeasonNumbers))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:seasonNumbers*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMissingEpisodesBySeries = `-- name: CountMissingEpisodesBySeries :one
SELECT COUNT(*) FROM episodes e
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.series_id = ?
  AND e.status IN ('missing', 'failed')
  AND sea.monitored = 1
  AND e.monitored = 1
`

func (q *Queries) CountMissingEpisodesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMissingEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNonFailedMonitoredEpisodesBySeason = `-- name: CountNonFailedMonitoredEpisodesBySeason :one
SELECT COUNT(*) FROM episodes
WHERE series_id = ?
  AND season_number = ?
  AND monitored = 1
  AND status NOT IN ('failed', 'unreleased')
`

type CountNonFailedMonitoredEpisodesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

// Portal request status: count non-failed monitored episodes for a specific season
func (q *Queries) CountNonFailedMonitoredEpisodesBySeason(ctx context.Context, arg CountNonFailedMonitoredEpisodesBySeasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNonFailedMonitoredEpisodesBySeason, arg.SeriesID, arg.SeasonNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNonFailedMonitoredEpisodesBySeries = `-- name: CountNonFailedMonitoredEpisodesBySeries :one
SELECT COUNT(*) FROM episodes
WHERE series_id = ?
  AND monitored = 1
  AND status NOT IN ('failed', 'unreleased')
`

// Portal request status: count non-failed monitored episodes for a series
func (q *Queries) CountNonFailedMonitoredEpisodesBySeries(ctx context.Context, seriesID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNonFailedMonitoredEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT(*) FROM series
`

func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    series_id, season_number, episode_number, title, overview, air_date, monitored, status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message
`

type CreateEpisodeParams struct {
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
	Status        string         `json:"status"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, createEpisode,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
		arg.Status,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const createEpisodeFile = `-- name: CreateEpisodeFile :one
INSERT INTO episode_files (episode_id, path, size, quality, quality_id, video_codec, audio_codec, resolution, audio_channels, dynamic_range)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type CreateEpisodeFileParams struct {
	EpisodeID     int64          `json:"episode_id"`
	Path          string         `json:"path"`
	Size          int64          `json:"size"`
	Quality       sql.NullString `json:"quality"`
	QualityID     sql.NullInt64  `json:"quality_id"`
	VideoCodec    sql.NullString `json:"video_codec"`
	AudioCodec    sql.NullString `json:"audio_codec"`
	Resolution    sql.NullString `json:"resolution"`
	AudioChannels sql.NullString `json:"audio_channels"`
	DynamicRange  sql.NullString `json:"dynamic_range"`
}

func (q *Queries) CreateEpisodeFile(ctx context.Context, arg CreateEpisodeFileParams) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, createEpisodeFile,
		arg.EpisodeID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.AudioChannels,
		arg.DynamicRange,
	)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const createEpisodeFileWithImportInfo = `-- name: CreateEpisodeFileWithImportInfo :one
INSERT INTO episode_files (
    episode_id, path, size, quality, quality_id, video_codec, audio_codec, resolution,
    audio_channels, dynamic_range, original_path, original_filename, imported_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type CreateEpisodeFileWithImportInfoParams struct {
	EpisodeID        int64          `json:"episode_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	AudioChannels    sql.NullString `json:"audio_channels"`
	DynamicRange     sql.NullString `json:"dynamic_range"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
}

// Import-related episode file operations
func (q *Queries) CreateEpisodeFileWithImportInfo(ctx context.Context, arg CreateEpisodeFileWithImportInfoParams) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, createEpisodeFileWithImportInfo,
		arg.EpisodeID,
		arg.Path,
		arg.Size,
		arg.Quality,
		arg.QualityID,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.AudioChannels,
		arg.DynamicRange,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
	)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const createSeason = `-- name: CreateSeason :one
INSERT INTO seasons (series_id, season_number, monitored)
VALUES (?, ?, ?)
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type CreateSeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
	Monitored    int64 `json:"monitored"`
}

func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, createSeason, arg.SeriesID, arg.SeasonNumber, arg.Monitored)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (
    title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime,
    path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type,
    network_logo_url, added_by
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by
`

type CreateSeriesParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	SeasonFolder     int64          `json:"season_folder"`
	ProductionStatus string         `json:"production_status"`
	Network          sql.NullString `json:"network"`
	FormatType       sql.NullString `json:"format_type"`
	NetworkLogoUrl   sql.NullString `json:"network_logo_url"`
	AddedBy          sql.NullInt64  `json:"added_by"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TvdbID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.SeasonFolder,
		arg.ProductionStatus,
		arg.Network,
		arg.FormatType,
		arg.NetworkLogoUrl,
		arg.AddedBy,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episodes WHERE id = ?
`

func (q *Queries) DeleteEpisode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode, id)
	return err
}

const deleteEpisodeFile = `-- name: DeleteEpisodeFile :exec
DELETE FROM episode_files WHERE id = ?
`

func (q *Queries) DeleteEpisodeFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeFile, id)
	return err
}

const deleteEpisodeFilesByEpisode = `-- name: DeleteEpisodeFilesByEpisode :exec
DELETE FROM episode_files WHERE episode_id = ?
`

func (q *Queries) DeleteEpisodeFilesByEpisode(ctx context.Context, episodeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeFilesByEpisode, episodeID)
	return err
}

const deleteEpisodesBySeries = `-- name: DeleteEpisodesBySeries :exec
DELETE FROM episodes WHERE series_id = ?
`

func (q *Queries) DeleteEpisodesBySeries(ctx context.Context, seriesID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodesBySeries, seriesID)
	return err
}

const deleteSeasonsBySeries = `-- name: DeleteSeasonsBySeries :exec
DELETE FROM seasons WHERE series_id = ?
`

func (q *Queries) DeleteSeasonsBySeries(ctx context.Context, seriesID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSeasonsBySeries, seriesID)
	return err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE FROM series WHERE id = ?
`

func (q *Queries) DeleteSeries(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSeries, id)
	return err
}

const deleteSeriesByRootFolder = `-- name: DeleteSeriesByRootFolder :exec
DELETE FROM series WHERE root_folder_id = ?
`

func (q *Queries) DeleteSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteSeriesByRootFolder, rootFolderID)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message FROM episodes WHERE id = ? LIMIT 1
`

// Episodes
func (q *Queries) GetEpisode(ctx context.Context, id int64) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getEpisodeAvailabilityForSeason = `-- name: GetEpisodeAvailabilityForSeason :many
SELECT
    e.episode_number,
    e.monitored,
    CASE WHEN e.air_date IS NOT NULL AND substr(e.air_date, 1, 10) <= date('now') THEN 1 ELSE 0 END as aired,
    CASE WHEN EXISTS (SELECT 1 FROM episode_slot_assignments esa WHERE esa.episode_id = e.id AND esa.file_id IS NOT NULL) THEN 1 ELSE 0 END as has_file
FROM episodes e
WHERE e.series_id = ? AND e.season_number = ?
ORDER BY e.episode_number
`

type GetEpisodeAvailabilityForSeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

type GetEpisodeAvailabilityForSeasonRow struct {
	EpisodeNumber int64 `json:"episode_number"`
	Monitored     int64 `json:"monitored"`
	Aired         int64 `json:"aired"`
	HasFile       int64 `json:"has_file"`
}

func (q *Queries) GetEpisodeAvailabilityForSeason(ctx context.Context, arg GetEpisodeAvailabilityForSeasonParams) ([]*GetEpisodeAvailabilityForSeasonRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeAvailabilityForSeason, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEpisodeAvailabilityForSeasonRow{}
	for rows.Next() {
		var i GetEpisodeAvailabilityForSeasonRow
		if err := rows.Scan(
			&i.EpisodeNumber,
			&i.Monitored,
			&i.Aired,
			&i.HasFile,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message FROM episodes
WHERE series_id = ? AND season_number = ? AND episode_number = ?
LIMIT 1
`

type GetEpisodeByNumberParams struct {
	SeriesID      int64 `json:"series_id"`
	SeasonNumber  int64 `json:"season_number"`
	EpisodeNumber int64 `json:"episode_number"`
}

func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeByNumber, arg.SeriesID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getEpisodeFile = `-- name: GetEpisodeFile :one
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM episode_files WHERE id = ? LIMIT 1
`

// Episode Files
func (q *Queries) GetEpisodeFile(ctx context.Context, id int64) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeFile, id)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getEpisodeFileByOriginalPath = `-- name: GetEpisodeFileByOriginalPath :one
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM episode_files WHERE original_path = ? LIMIT 1
`

func (q *Queries) GetEpisodeFileByOriginalPath(ctx context.Context, originalPath sql.NullString) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeFileByOriginalPath, originalPath)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getEpisodeFileByPath = `-- name: GetEpisodeFileByPath :one
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM episode_files WHERE path = ? LIMIT 1
`

func (q *Queries) GetEpisodeFileByPath(ctx context.Context, path string) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeFileByPath, path)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const getEpisodeFilesWithImportInfo = `-- name: GetEpisodeFilesWithImportInfo :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, ef.audio_channels, ef.dynamic_range, e.series_id, e.season_number, e.episode_number
FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ?
ORDER BY ef.imported_at DESC
`

type GetEpisodeFilesWithImportInfoRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	AudioChannels    sql.NullString `json:"audio_channels"`
	DynamicRange     sql.NullString `json:"dynamic_range"`
	SeriesID         int64          `json:"series_id"`
	SeasonNumber     int64          `json:"season_number"`
	EpisodeNumber    int64          `json:"episode_number"`
}

func (q *Queries) GetEpisodeFilesWithImportInfo(ctx context.Context, seriesID int64) ([]*GetEpisodeFilesWithImportInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeFilesWithImportInfo, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEpisodeFilesWithImportInfoRow{}
	for rows.Next() {
		var i GetEpisodeFilesWithImportInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeStatusCountsBySeason = `-- name: GetEpisodeStatusCountsBySeason :one
SELECT
    COALESCE(SUM(CASE WHEN e.status = 'unreleased' THEN 1 ELSE 0 END), 0) as unreleased,
    COALESCE(SUM(CASE WHEN e.status = 'missing' THEN 1 ELSE 0 END), 0) as missing,
    COALESCE(SUM(CASE WHEN e.status = 'downloading' THEN 1 ELSE 0 END), 0) as downloading,
    COALESCE(SUM(CASE WHEN e.status = 'failed' THEN 1 ELSE 0 END), 0) as failed,
    COALESCE(SUM(CASE WHEN e.status = 'upgradable' THEN 1 ELSE 0 END), 0) as upgradable,
    COALESCE(SUM(CASE WHEN e.status = 'available' THEN 1 ELSE 0 END), 0) as available,
    COUNT(*) as total
FROM episodes e
WHERE e.series_id = ? AND e.season_number = ?
`

type GetEpisodeStatusCountsBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

type GetEpisodeStatusCountsBySeasonRow struct {
	Unreleased  interface{} `json:"unreleased"`
	Missing     interface{} `json:"missing"`
	Downloading interface{} `json:"downloading"`
	Failed      interface{} `json:"failed"`
	Upgradable  interface{} `json:"upgradable"`
	Available   interface{} `json:"available"`
	Total       int64       `json:"total"`
}

func (q *Queries) GetEpisodeStatusCountsBySeason(ctx context.Context, arg GetEpisodeStatusCountsBySeasonParams) (*GetEpisodeStatusCountsBySeasonRow, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeStatusCountsBySeason, arg.SeriesID, arg.SeasonNumber)
	var i GetEpisodeStatusCountsBySeasonRow
	err := row.Scan(
		&i.Unreleased,
		&i.Missing,
		&i.Downloading,
		&i.Failed,
		&i.Upgradable,
		&i.Available,
		&i.Total,
	)
	return &i, err
}

const getEpisodeStatusCountsBySeries = `-- name: GetEpisodeStatusCountsBySeries :one
SELECT
    COALESCE(SUM(CASE WHEN e.status = 'unreleased' THEN 1 ELSE 0 END), 0) as unreleased,
    COALESCE(SUM(CASE WHEN e.status = 'missing' THEN 1 ELSE 0 END), 0) as missing,
    COALESCE(SUM(CASE WHEN e.status = 'downloading' THEN 1 ELSE 0 END), 0) as downloading,
    COALESCE(SUM(CASE WHEN e.status = 'failed' THEN 1 ELSE 0 END), 0) as failed,
    COALESCE(SUM(CASE WHEN e.status = 'upgradable' THEN 1 ELSE 0 END), 0) as upgradable,
    COALESCE(SUM(CASE WHEN e.status = 'available' THEN 1 ELSE 0 END), 0) as available,
    COUNT(*) as total,
    MIN(e.air_date) as first_aired,
    MAX(CASE WHEN substr(e.air_date, 1, 10) <= date('now') THEN e.air_date END) as last_aired,
    MIN(CASE WHEN substr(e.air_date, 1, 10) > date('now') THEN e.air_date END) as next_airing
FROM episodes e
WHERE e.series_id = ? AND e.season_number > 0
`

type GetEpisodeStatusCountsBySeriesRow struct {
	Unreleased  interface{} `json:"unreleased"`
	Missing     interface{} `json:"missing"`
	Downloading interface{} `json:"downloading"`
	Failed      interface{} `json:"failed"`
	Upgradable  interface{} `json:"upgradable"`
	Available   interface{} `json:"available"`
	Total       int64       `json:"total"`
	FirstAired  interface{} `json:"first_aired"`
	LastAired   interface{} `json:"last_aired"`
	NextAiring  interface{} `json:"next_airing"`
}

// StatusCounts computation
func (q *Queries) GetEpisodeStatusCountsBySeries(ctx context.Context, seriesID int64) (*GetEpisodeStatusCountsBySeriesRow, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeStatusCountsBySeries, seriesID)
	var i GetEpisodeStatusCountsBySeriesRow
	err := row.Scan(
		&i.Unreleased,
		&i.Missing,
		&i.Downloading,
		&i.Failed,
		&i.Upgradable,
		&i.Available,
		&i.Total,
		&i.FirstAired,
		&i.LastAired,
		&i.NextAiring,
	)
	return &i, err
}

const getEpisodeWithFileQuality = `-- name: GetEpisodeWithFileQuality :one
SELECT
    e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message,
    s.quality_profile_id as series_quality_profile_id,
    ef.id as file_id,
    ef.quality_id as current_quality_id
FROM episodes e
JOIN series s ON e.series_id = s.id
LEFT JOIN episode_files ef ON e.id = ef.episode_id
WHERE e.id = ?
LIMIT 1
`

type GetEpisodeWithFileQualityRow struct {
	ID                     int64          `json:"id"`
	SeriesID               int64          `json:"series_id"`
	SeasonNumber           int64          `json:"season_number"`
	EpisodeNumber          int64          `json:"episode_number"`
	Title                  sql.NullString `json:"title"`
	Overview               sql.NullString `json:"overview"`
	AirDate                sql.NullTime   `json:"air_date"`
	Monitored              int64          `json:"monitored"`
	Status                 string         `json:"status"`
	ActiveDownloadID       sql.NullString `json:"active_download_id"`
	StatusMessage          sql.NullString `json:"status_message"`
	SeriesQualityProfileID sql.NullInt64  `json:"series_quality_profile_id"`
	FileID                 sql.NullInt64  `json:"file_id"`
	CurrentQualityID       sql.NullInt64  `json:"current_quality_id"`
}

func (q *Queries) GetEpisodeWithFileQuality(ctx context.Context, id int64) (*GetEpisodeWithFileQualityRow, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeWithFileQuality, id)
	var i GetEpisodeWithFileQualityRow
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
		&i.SeriesQualityProfileID,
		&i.FileID,
		&i.CurrentQualityID,
	)
	return &i, err
}

const getEpisodesInDateRange = `-- name: GetEpisodesInDateRange :many
SELECT
    e.id,
    e.series_id,
    e.season_number,
    e.episode_number,
    e.title,
    e.overview,
    e.air_date,
    e.monitored,
    e.status,
    s.title as series_title,
    s.network,
    s.tmdb_id as series_tmdb_id
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE e.air_date BETWEEN ? AND ?
    AND e.season_number > 0
ORDER BY e.air_date, s.title, e.season_number, e.episode_number
`

type GetEpisodesInDateRangeParams struct {
	AirDate   sql.NullTime `json:"air_date"`
	AirDate_2 sql.NullTime `json:"air_date_2"`
}

type GetEpisodesInDateRangeRow struct {
	ID            int64          `json:"id"`
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
	Status        string         `json:"status"`
	SeriesTitle   string         `json:"series_title"`
	Network       sql.NullString `json:"network"`
	SeriesTmdbID  sql.NullInt64  `json:"series_tmdb_id"`
}

// Calendar queries
func (q *Queries) GetEpisodesInDateRange(ctx context.Context, arg GetEpisodesInDateRangeParams) ([]*GetEpisodesInDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodesInDateRange, arg.AirDate, arg.AirDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEpisodesInDateRangeRow{}
	for rows.Next() {
		var i GetEpisodesInDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.SeriesTitle,
			&i.Network,
			&i.SeriesTmdbID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSeasonNumber = `-- name: GetLatestSeasonNumber :one
SELECT COALESCE(MAX(season_number), 0) as latest FROM seasons WHERE series_id = ? AND season_number > 0
`

func (q *Queries) GetLatestSeasonNumber(ctx context.Context, seriesID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestSeasonNumber, seriesID)
	var latest interface{}
	err := row.Scan(&latest)
	return latest, err
}

const getMissingEpisodesBySeries = `-- name: GetMissingEpisodesBySeries :many
SELECT e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message FROM episodes e
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.series_id = ?
  AND e.status IN ('missing', 'failed')
  AND sea.monitored = 1
  AND e.monitored = 1
ORDER BY e.season_number, e.episode_number
`

func (q *Queries) GetMissingEpisodesBySeries(ctx context.Context, seriesID int64) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, getMissingEpisodesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE id = ? LIMIT 1
`

// Seasons
func (q *Queries) GetSeason(ctx context.Context, id int64) (*Season, error) {
	row := q.db.QueryRowContext(ctx, getSeason, id)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const getSeasonByNumber = `-- name: GetSeasonByNumber :one
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE series_id = ? AND season_number = ? LIMIT 1
`

type GetSeasonByNumberParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) GetSeasonByNumber(ctx context.Context, arg GetSeasonByNumberParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, getSeasonByNumber, arg.SeriesID, arg.SeasonNumber)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const getSeasonsBySeriesID = `-- name: GetSeasonsBySeriesID :many
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE series_id = ? ORDER BY season_number
`

func (q *Queries) GetSeasonsBySeriesID(ctx context.Context, seriesID int64) ([]*Season, error) {
	rows, err := q.db.QueryContext(ctx, getSeasonsBySeriesID, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Season{}
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.Monitored,
			&i.Overview,
			&i.PosterUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeries = `-- name: GetSeries :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE id = ? LIMIT 1
`

func (q *Queries) GetSeries(ctx context.Context, id int64) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const getSeriesByPath = `-- name: GetSeriesByPath :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE path = ? LIMIT 1
`

func (q *Queries) GetSeriesByPath(ctx context.Context, path sql.NullString) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByPath, path)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const getSeriesByTmdbID = `-- name: GetSeriesByTmdbID :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE tmdb_id = ? LIMIT 1
`

func (q *Queries) GetSeriesByTmdbID(ctx context.Context, tmdbID sql.NullInt64) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByTmdbID, tmdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const getSeriesByTvdbID = `-- name: GetSeriesByTvdbID :one
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE tvdb_id = ? LIMIT 1
`

func (q *Queries) GetSeriesByTvdbID(ctx context.Context, tvdbID sql.NullInt64) (*Series, error) {
	row := q.db.QueryRowContext(ctx, getSeriesByTvdbID, tvdbID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const getSeriesFormatType = `-- name: GetSeriesFormatType :one
SELECT format_type FROM series WHERE id = ?
`

func (q *Queries) GetSeriesFormatType(ctx context.Context, id int64) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSeriesFormatType, id)
	var format_type sql.NullString
	err := row.Scan(&format_type)
	return format_type, err
}

const getSeriesMonitoringStats = `-- name: GetSeriesMonitoringStats :one
SELECT
    (SELECT COUNT(*) FROM seasons s WHERE s.series_id = ?) as total_seasons,
    (SELECT COUNT(*) FROM seasons s WHERE s.series_id = ? AND s.monitored = 1) as monitored_seasons,
    (SELECT COUNT(*) FROM episodes e WHERE e.series_id = ?) as total_episodes,
    (SELECT COUNT(*) FROM episodes e WHERE e.series_id = ? AND e.monitored = 1) as monitored_episodes
`

type GetSeriesMonitoringStatsParams struct {
	SeriesID   int64 `json:"series_id"`
	SeriesID_2 int64 `json:"series_id_2"`
	SeriesID_3 int64 `json:"series_id_3"`
	SeriesID_4 int64 `json:"series_id_4"`
}

type GetSeriesMonitoringStatsRow struct {
	TotalSeasons      int64 `json:"total_seasons"`
	MonitoredSeasons  int64 `json:"monitored_seasons"`
	TotalEpisodes     int64 `json:"total_episodes"`
	MonitoredEpisodes int64 `json:"monitored_episodes"`
}

// Monitoring status queries
func (q *Queries) GetSeriesMonitoringStats(ctx context.Context, arg GetSeriesMonitoringStatsParams) (*GetSeriesMonitoringStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSeriesMonitoringStats,
		arg.SeriesID,
		arg.SeriesID_2,
		arg.SeriesID_3,
		arg.SeriesID_4,
	)
	var i GetSeriesMonitoringStatsRow
	err := row.Scan(
		&i.TotalSeasons,
		&i.MonitoredSeasons,
		&i.TotalEpisodes,
		&i.MonitoredEpisodes,
	)
	return &i, err
}

const getSeriesSeasonAvailabilitySummary = `-- name: GetSeriesSeasonAvailabilitySummary :many
SELECT
    sea.season_number,
    sea.monitored,
    COUNT(e.id) as total_episodes,
    COALESCE(SUM(CASE WHEN e.air_date IS NOT NULL AND substr(e.air_date, 1, 10) <= date('now') THEN 1 ELSE 0 END), 0) as aired_episodes,
    COALESCE(SUM(CASE WHEN e.air_date IS NOT NULL AND substr(e.air_date, 1, 10) <= date('now')
        AND EXISTS (SELECT 1 FROM episode_slot_assignments esa WHERE esa.episode_id = e.id AND esa.file_id IS NOT NULL)
        THEN 1 ELSE 0 END), 0) as aired_with_files,
    COALESCE(SUM(CASE WHEN (e.air_date IS NULL OR substr(e.air_date, 1, 10) > date('now'))
        AND e.monitored = 1 THEN 1 ELSE 0 END), 0) as unaired_monitored
FROM seasons sea
LEFT JOIN episodes e ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE sea.series_id = ? AND sea.season_number > 0
GROUP BY sea.season_number, sea.monitored
ORDER BY sea.season_number
`

type GetSeriesSeasonAvailabilitySummaryRow struct {
	SeasonNumber     int64       `json:"season_number"`
	Monitored        int64       `json:"monitored"`
	TotalEpisodes    int64       `json:"total_episodes"`
	AiredEpisodes    interface{} `json:"aired_episodes"`
	AiredWithFiles   interface{} `json:"aired_with_files"`
	UnairedMonitored interface{} `json:"unaired_monitored"`
}

func (q *Queries) GetSeriesSeasonAvailabilitySummary(ctx context.Context, seriesID int64) ([]*GetSeriesSeasonAvailabilitySummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSeriesSeasonAvailabilitySummary, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSeriesSeasonAvailabilitySummaryRow{}
	for rows.Next() {
		var i GetSeriesSeasonAvailabilitySummaryRow
		if err := rows.Scan(
			&i.SeasonNumber,
			&i.Monitored,
			&i.TotalEpisodes,
			&i.AiredEpisodes,
			&i.AiredWithFiles,
			&i.UnairedMonitored,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesWithAddedBy = `-- name: GetSeriesWithAddedBy :one
SELECT s.id, s.title, s.sort_title, s.year, s.tvdb_id, s.tmdb_id, s.imdb_id, s.overview, s.runtime, s.path, s.root_folder_id, s.quality_profile_id, s.monitored, s.season_folder, s.production_status, s.network, s.format_type, s.added_at, s.updated_at, s.network_logo_url, s.added_by, pu.username AS added_by_username FROM series s
LEFT JOIN portal_users pu ON s.added_by = pu.id
WHERE s.id = ? LIMIT 1
`

type GetSeriesWithAddedByRow struct {
	ID               int64          `json:"id"`
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	SeasonFolder     int64          `json:"season_folder"`
	ProductionStatus string         `json:"production_status"`
	Network          sql.NullString `json:"network"`
	FormatType       sql.NullString `json:"format_type"`
	AddedAt          sql.NullTime   `json:"added_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	NetworkLogoUrl   sql.NullString `json:"network_logo_url"`
	AddedBy          sql.NullInt64  `json:"added_by"`
	AddedByUsername  sql.NullString `json:"added_by_username"`
}

func (q *Queries) GetSeriesWithAddedBy(ctx context.Context, id int64) (*GetSeriesWithAddedByRow, error) {
	row := q.db.QueryRowContext(ctx, getSeriesWithAddedBy, id)
	var i GetSeriesWithAddedByRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
		&i.AddedByUsername,
	)
	return &i, err
}

const isOriginalPathImportedEpisode = `-- name: IsOriginalPathImportedEpisode :one
SELECT EXISTS(SELECT 1 FROM episode_files WHERE original_path = ?) AS imported
`

func (q *Queries) IsOriginalPathImportedEpisode(ctx context.Context, originalPath sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, isOriginalPathImportedEpisode, originalPath)
	var imported int64
	err := row.Scan(&imported)
	return imported, err
}

const listAllEpisodeFilePaths = `-- name: ListAllEpisodeFilePaths :many
SELECT path FROM episode_files
`

func (q *Queries) ListAllEpisodeFilePaths(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllEpisodeFilePaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadingEpisodes = `-- name: ListDownloadingEpisodes :many
SELECT id, series_id, active_download_id FROM episodes
WHERE status = 'downloading' AND active_download_id IS NOT NULL
`

type ListDownloadingEpisodesRow struct {
	ID               int64          `json:"id"`
	SeriesID         int64          `json:"series_id"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
}

func (q *Queries) ListDownloadingEpisodes(ctx context.Context) ([]*ListDownloadingEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDownloadingEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListDownloadingEpisodesRow{}
	for rows.Next() {
		var i ListDownloadingEpisodesRow
		if err := rows.Scan(&i.ID, &i.SeriesID, &i.ActiveDownloadID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesByEpisode = `-- name: ListEpisodeFilesByEpisode :many
SELECT id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range FROM episode_files WHERE episode_id = ? ORDER BY path
`

func (q *Queries) ListEpisodeFilesByEpisode(ctx context.Context, episodeID int64) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesByEpisode, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesBySeason = `-- name: ListEpisodeFilesBySeason :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, ef.audio_channels, ef.dynamic_range FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ? AND e.season_number = ?
ORDER BY e.episode_number
`

type ListEpisodeFilesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) ListEpisodeFilesBySeason(ctx context.Context, arg ListEpisodeFilesBySeasonParams) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesBySeason, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesBySeries = `-- name: ListEpisodeFilesBySeries :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, ef.audio_channels, ef.dynamic_range FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
WHERE e.series_id = ?
ORDER BY e.season_number, e.episode_number
`

func (q *Queries) ListEpisodeFilesBySeries(ctx context.Context, seriesID int64) ([]*EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodeFile{}
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.AudioChannels,
			&i.DynamicRange,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesForRootFolder = `-- name: ListEpisodeFilesForRootFolder :many
SELECT ef.id as file_id, ef.path, ef.episode_id, e.status as episode_status
FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE s.root_folder_id = ?
  AND e.status IN ('available', 'upgradable')
`

type ListEpisodeFilesForRootFolderRow struct {
	FileID        int64  `json:"file_id"`
	Path          string `json:"path"`
	EpisodeID     int64  `json:"episode_id"`
	EpisodeStatus string `json:"episode_status"`
}

func (q *Queries) ListEpisodeFilesForRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*ListEpisodeFilesForRootFolderRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesForRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeFilesForRootFolderRow{}
	for rows.Next() {
		var i ListEpisodeFilesForRootFolderRow
		if err := rows.Scan(
			&i.FileID,
			&i.Path,
			&i.EpisodeID,
			&i.EpisodeStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeUpgradeCandidates = `-- name: ListEpisodeUpgradeCandidates :many
SELECT
    e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message,
    s.title as series_title,
    s.tvdb_id as series_tvdb_id,
    s.tmdb_id as series_tmdb_id,
    s.imdb_id as series_imdb_id,
    s.year as series_year,
    s.quality_profile_id as series_quality_profile_id,
    ef.quality_id as current_quality_id
FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
JOIN episode_files ef ON ef.id = (
    SELECT id FROM episode_files WHERE episode_id = e.id ORDER BY id DESC LIMIT 1
)
WHERE e.status = 'upgradable'
  AND e.monitored = 1
  AND s.monitored = 1
  AND sea.monitored = 1
ORDER BY e.air_date DESC
`

type ListEpisodeUpgradeCandidatesRow struct {
	ID                     int64          `json:"id"`
	SeriesID               int64          `json:"series_id"`
	SeasonNumber           int64          `json:"season_number"`
	EpisodeNumber          int64          `json:"episode_number"`
	Title                  sql.NullString `json:"title"`
	Overview               sql.NullString `json:"overview"`
	AirDate                sql.NullTime   `json:"air_date"`
	Monitored              int64          `json:"monitored"`
	Status                 string         `json:"status"`
	ActiveDownloadID       sql.NullString `json:"active_download_id"`
	StatusMessage          sql.NullString `json:"status_message"`
	SeriesTitle            string         `json:"series_title"`
	SeriesTvdbID           sql.NullInt64  `json:"series_tvdb_id"`
	SeriesTmdbID           sql.NullInt64  `json:"series_tmdb_id"`
	SeriesImdbID           sql.NullString `json:"series_imdb_id"`
	SeriesYear             sql.NullInt64  `json:"series_year"`
	SeriesQualityProfileID sql.NullInt64  `json:"series_quality_profile_id"`
	CurrentQualityID       sql.NullInt64  `json:"current_quality_id"`
}

// Upgrade candidate queries (status-based)
func (q *Queries) ListEpisodeUpgradeCandidates(ctx context.Context) ([]*ListEpisodeUpgradeCandidatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeUpgradeCandidates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeUpgradeCandidatesRow{}
	for rows.Next() {
		var i ListEpisodeUpgradeCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SeriesTitle,
			&i.SeriesTvdbID,
			&i.SeriesTmdbID,
			&i.SeriesImdbID,
			&i.SeriesYear,
			&i.SeriesQualityProfileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeUpgradeCandidatesBySeries = `-- name: ListEpisodeUpgradeCandidatesBySeries :many
SELECT
    e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message
FROM episodes e
JOIN series s ON e.series_id = s.id
WHERE e.series_id = ?
  AND e.status = 'upgradable'
  AND e.monitored = 1
ORDER BY e.season_number, e.episode_number
`

func (q *Queries) ListEpisodeUpgradeCandidatesBySeries(ctx context.Context, seriesID int64) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeUpgradeCandidatesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeason = `-- name: ListEpisodesBySeason :many
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message FROM episodes WHERE series_id = ? AND season_number = ? ORDER BY episode_number
`

type ListEpisodesBySeasonParams struct {
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) ListEpisodesBySeason(ctx context.Context, arg ListEpisodesBySeasonParams) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodesBySeason, arg.SeriesID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeries = `-- name: ListEpisodesBySeries :many
SELECT id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message FROM episodes WHERE series_id = ? ORDER BY season_number, episode_number
`

func (q *Queries) ListEpisodesBySeries(ctx context.Context, seriesID int64) ([]*Episode, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesWithFilesForProfile = `-- name: ListEpisodesWithFilesForProfile :many
SELECT e.id, e.status, ef.id as file_id, ef.quality_id as current_quality_id
FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN episode_files ef ON e.id = ef.episode_id
WHERE s.quality_profile_id = ?
  AND e.status IN ('available', 'upgradable')
  AND ef.quality_id IS NOT NULL
`

type ListEpisodesWithFilesForProfileRow struct {
	ID               int64         `json:"id"`
	Status           string        `json:"status"`
	FileID           int64         `json:"file_id"`
	CurrentQualityID sql.NullInt64 `json:"current_quality_id"`
}

// Quality profile recalculation: find episodes with files to evaluate against new cutoff
func (q *Queries) ListEpisodesWithFilesForProfile(ctx context.Context, qualityProfileID sql.NullInt64) ([]*ListEpisodesWithFilesForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodesWithFilesForProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodesWithFilesForProfileRow{}
	for rows.Next() {
		var i ListEpisodesWithFilesForProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMissingEpisodes = `-- name: ListMissingEpisodes :many
SELECT
    e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message,
    s.title as series_title,
    s.tvdb_id as series_tvdb_id,
    s.tmdb_id as series_tmdb_id,
    s.imdb_id as series_imdb_id,
    s.year as series_year,
    s.quality_profile_id as series_quality_profile_id
FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.status IN ('missing', 'failed')
  AND s.monitored = 1
  AND sea.monitored = 1
  AND e.monitored = 1
ORDER BY e.air_date DESC
`

type ListMissingEpisodesRow struct {
	ID                     int64          `json:"id"`
	SeriesID               int64          `json:"series_id"`
	SeasonNumber           int64          `json:"season_number"`
	EpisodeNumber          int64          `json:"episode_number"`
	Title                  sql.NullString `json:"title"`
	Overview               sql.NullString `json:"overview"`
	AirDate                sql.NullTime   `json:"air_date"`
	Monitored              int64          `json:"monitored"`
	Status                 string         `json:"status"`
	ActiveDownloadID       sql.NullString `json:"active_download_id"`
	StatusMessage          sql.NullString `json:"status_message"`
	SeriesTitle            string         `json:"series_title"`
	SeriesTvdbID           sql.NullInt64  `json:"series_tvdb_id"`
	SeriesTmdbID           sql.NullInt64  `json:"series_tmdb_id"`
	SeriesImdbID           sql.NullString `json:"series_imdb_id"`
	SeriesYear             sql.NullInt64  `json:"series_year"`
	SeriesQualityProfileID sql.NullInt64  `json:"series_quality_profile_id"`
}

// Missing episodes queries (status-based, respects cascading monitoring)
func (q *Queries) ListMissingEpisodes(ctx context.Context) ([]*ListMissingEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMissingEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMissingEpisodesRow{}
	for rows.Next() {
		var i ListMissingEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SeriesTitle,
			&i.SeriesTvdbID,
			&i.SeriesTmdbID,
			&i.SeriesImdbID,
			&i.SeriesYear,
			&i.SeriesQualityProfileID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredSeries = `-- name: ListMonitoredSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE monitored = 1 ORDER BY sort_title
`

func (q *Queries) ListMonitoredSeries(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeasonsBySeries = `-- name: ListSeasonsBySeries :many
SELECT id, series_id, season_number, monitored, overview, poster_url FROM seasons WHERE series_id = ? ORDER BY season_number
`

func (q *Queries) ListSeasonsBySeries(ctx context.Context, seriesID int64) ([]*Season, error) {
	rows, err := q.db.QueryContext(ctx, listSeasonsBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Season{}
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.Monitored,
			&i.Overview,
			&i.PosterUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series ORDER BY sort_title
`

func (q *Queries) ListSeries(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesByRootFolder = `-- name: ListSeriesByRootFolder :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series WHERE root_folder_id = ? ORDER BY sort_title
`

func (q *Queries) ListSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesPaginated = `-- name: ListSeriesPaginated :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series
ORDER BY sort_title
LIMIT ? OFFSET ?
`

type ListSeriesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSeriesPaginated(ctx context.Context, arg ListSeriesPaginatedParams) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesWithMissingEpisodes = `-- name: ListSeriesWithMissingEpisodes :many
SELECT DISTINCT s.id, s.title, s.sort_title, s.year, s.tvdb_id, s.tmdb_id, s.imdb_id, s.overview, s.runtime, s.path, s.root_folder_id, s.quality_profile_id, s.monitored, s.season_folder, s.production_status, s.network, s.format_type, s.added_at, s.updated_at, s.network_logo_url, s.added_by FROM series s
JOIN episodes e ON s.id = e.series_id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
WHERE e.status IN ('missing', 'failed')
  AND s.monitored = 1
  AND sea.monitored = 1
  AND e.monitored = 1
ORDER BY s.sort_title
`

func (q *Queries) ListSeriesWithMissingEpisodes(ctx context.Context) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeriesWithMissingEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedSeriesByRootFolder = `-- name: ListUnmatchedSeriesByRootFolder :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series
WHERE root_folder_id = ?
  AND (tvdb_id IS NULL OR tvdb_id = 0)
  AND (tmdb_id IS NULL OR tmdb_id = 0)
ORDER BY sort_title
`

func (q *Queries) ListUnmatchedSeriesByRootFolder(ctx context.Context, rootFolderID sql.NullInt64) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedSeriesByRootFolder, rootFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpgradableEpisodesWithQuality = `-- name: ListUpgradableEpisodesWithQuality :many
SELECT e.id, e.series_id, e.season_number, e.episode_number, e.title, e.overview, e.air_date, e.monitored, e.status, e.active_download_id, e.status_message, s.title as series_title, s.tvdb_id as series_tvdb_id,
       s.tmdb_id as series_tmdb_id, s.imdb_id as series_imdb_id,
       s.year as series_year, s.quality_profile_id as series_quality_profile_id,
       ef.quality_id as current_quality_id
FROM episodes e
JOIN series s ON e.series_id = s.id
JOIN seasons sea ON e.series_id = sea.series_id AND e.season_number = sea.season_number
JOIN episode_files ef ON ef.id = (
    SELECT id FROM episode_files WHERE episode_id = e.id ORDER BY id DESC LIMIT 1
)
WHERE e.status = 'upgradable' AND e.monitored = 1 AND s.monitored = 1 AND sea.monitored = 1
ORDER BY e.air_date DESC
`

type ListUpgradableEpisodesWithQualityRow struct {
	ID                     int64          `json:"id"`
	SeriesID               int64          `json:"series_id"`
	SeasonNumber           int64          `json:"season_number"`
	EpisodeNumber          int64          `json:"episode_number"`
	Title                  sql.NullString `json:"title"`
	Overview               sql.NullString `json:"overview"`
	AirDate                sql.NullTime   `json:"air_date"`
	Monitored              int64          `json:"monitored"`
	Status                 string         `json:"status"`
	ActiveDownloadID       sql.NullString `json:"active_download_id"`
	StatusMessage          sql.NullString `json:"status_message"`
	SeriesTitle            string         `json:"series_title"`
	SeriesTvdbID           sql.NullInt64  `json:"series_tvdb_id"`
	SeriesTmdbID           sql.NullInt64  `json:"series_tmdb_id"`
	SeriesImdbID           sql.NullString `json:"series_imdb_id"`
	SeriesYear             sql.NullInt64  `json:"series_year"`
	SeriesQualityProfileID sql.NullInt64  `json:"series_quality_profile_id"`
	CurrentQualityID       sql.NullInt64  `json:"current_quality_id"`
}

// Upgradable episodes with current file quality
func (q *Queries) ListUpgradableEpisodesWithQuality(ctx context.Context) ([]*ListUpgradableEpisodesWithQualityRow, error) {
	rows, err := q.db.QueryContext(ctx, listUpgradableEpisodesWithQuality)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUpgradableEpisodesWithQualityRow{}
	for rows.Next() {
		var i ListUpgradableEpisodesWithQualityRow
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.Overview,
			&i.AirDate,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SeriesTitle,
			&i.SeriesTvdbID,
			&i.SeriesTmdbID,
			&i.SeriesImdbID,
			&i.SeriesYear,
			&i.SeriesQualityProfileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSeries = `-- name: SearchSeries :many
SELECT id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by FROM series
WHERE title LIKE ?1 OR sort_title LIKE ?1
   OR REPLACE(title, '''', '') LIKE ?1
   OR REPLACE(sort_title, '''', '') LIKE ?1
ORDER BY sort_title
LIMIT ?3 OFFSET ?2
`

type SearchSeriesParams struct {
	SearchTerm string `json:"search_term"`
	Off        int64  `json:"off"`
	Lim        int64  `json:"lim"`
}

func (q *Queries) SearchSeries(ctx context.Context, arg SearchSeriesParams) ([]*Series, error) {
	rows, err := q.db.QueryContext(ctx, searchSeries, arg.SearchTerm, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TvdbID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.SeasonFolder,
			&i.ProductionStatus,
			&i.Network,
			&i.FormatType,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.NetworkLogoUrl,
			&i.AddedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAllEpisodesMonitoredBySeries = `-- name: UpdateAllEpisodesMonitoredBySeries :exec
UPDATE episodes SET monitored = ? WHERE series_id = ?
`

type UpdateAllEpisodesMonitoredBySeriesParams struct {
	Monitored int64 `json:"monitored"`
	SeriesID  int64 `json:"series_id"`
}

// Bulk monitoring updates for add flow
func (q *Queries) UpdateAllEpisodesMonitoredBySeries(ctx context.Context, arg UpdateAllEpisodesMonitoredBySeriesParams) error {
	_, err := q.db.ExecContext(ctx, updateAllEpisodesMonitoredBySeries, arg.Monitored, arg.SeriesID)
	return err
}

const updateAllEpisodesMonitoredBySeriesIDs = `-- name: UpdateAllEpisodesMonitoredBySeriesIDs :exec
UPDATE episodes SET monitored = ? WHERE series_id IN (/*SLICE:ids*/?)
`

type UpdateAllEpisodesMonitoredBySeriesIDsParams struct {
	Monitored int64   `json:"monitored"`
	Ids       []int64 `json:"ids"`
}

func (q *Queries) UpdateAllEpisodesMonitoredBySeriesIDs(ctx context.Context, arg UpdateAllEpisodesMonitoredBySeriesIDsParams) error {
	query := updateAllEpisodesMonitoredBySeriesIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes SET
    title = ?,
    overview = ?,
    air_date = ?,
    monitored = ?
WHERE id = ?
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message
`

type UpdateEpisodeParams struct {
	Title     sql.NullString `json:"title"`
	Overview  sql.NullString `json:"overview"`
	AirDate   sql.NullTime   `json:"air_date"`
	Monitored int64          `json:"monitored"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, updateEpisode,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
		arg.ID,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const updateEpisodeFileImportInfo = `-- name: UpdateEpisodeFileImportInfo :one
UPDATE episode_files SET
    original_path = ?,
    original_filename = ?,
    imported_at = ?
WHERE id = ?
RETURNING id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id, audio_channels, dynamic_range
`

type UpdateEpisodeFileImportInfoParams struct {
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateEpisodeFileImportInfo(ctx context.Context, arg UpdateEpisodeFileImportInfoParams) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, updateEpisodeFileImportInfo,
		arg.OriginalPath,
		arg.OriginalFilename,
		arg.ImportedAt,
		arg.ID,
	)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
		&i.AudioChannels,
		&i.DynamicRange,
	)
	return &i, err
}

const updateEpisodeFileMediaInfo = `-- name: UpdateEpisodeFileMediaInfo :exec
UPDATE episode_files SET
    video_codec = ?,
    audio_codec = ?,
    resolution = ?
WHERE episode_id = ?
`

type UpdateEpisodeFileMediaInfoParams struct {
	VideoCodec sql.NullString `json:"video_codec"`
	AudioCodec sql.NullString `json:"audio_codec"`
	Resolution sql.NullString `json:"resolution"`
	EpisodeID  int64          `json:"episode_id"`
}

func (q *Queries) UpdateEpisodeFileMediaInfo(ctx context.Context, arg UpdateEpisodeFileMediaInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeFileMediaInfo,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Resolution,
		arg.EpisodeID,
	)
	return err
}

const updateEpisodeFilePath = `-- name: UpdateEpisodeFilePath :exec
UPDATE episode_files SET path = ? WHERE id = ?
`

type UpdateEpisodeFilePathParams struct {
	Path string `json:"path"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateEpisodeFilePath(ctx context.Context, arg UpdateEpisodeFilePathParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeFilePath, arg.Path, arg.ID)
	return err
}

const updateEpisodeFileQualityID = `-- name: UpdateEpisodeFileQualityID :exec
UPDATE episode_files SET quality_id = ? WHERE id = ?
`

type UpdateEpisodeFileQualityIDParams struct {
	QualityID sql.NullInt64 `json:"quality_id"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateEpisodeFileQualityID(ctx context.Context, arg UpdateEpisodeFileQualityIDParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeFileQualityID, arg.QualityID, arg.ID)
	return err
}

const updateEpisodeMonitored = `-- name: UpdateEpisodeMonitored :exec
UPDATE episodes SET monitored = ? WHERE id = ?
`

type UpdateEpisodeMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateEpisodeMonitored(ctx context.Context, arg UpdateEpisodeMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeMonitored, arg.Monitored, arg.ID)
	return err
}

const updateEpisodeStatus = `-- name: UpdateEpisodeStatus :exec
UPDATE episodes SET status = ? WHERE id = ?
`

type UpdateEpisodeStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateEpisodeStatus(ctx context.Context, arg UpdateEpisodeStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeStatus, arg.Status, arg.ID)
	return err
}

const updateEpisodeStatusWithDetails = `-- name: UpdateEpisodeStatusWithDetails :exec
UPDATE episodes SET
    status = ?,
    active_download_id = ?,
    status_message = ?
WHERE id = ?
`

type UpdateEpisodeStatusWithDetailsParams struct {
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateEpisodeStatusWithDetails(ctx context.Context, arg UpdateEpisodeStatusWithDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeStatusWithDetails,
		arg.Status,
		arg.ActiveDownloadID,
		arg.StatusMessage,
		arg.ID,
	)
	return err
}

const updateEpisodesMonitoredByIDs = `-- name: UpdateEpisodesMonitoredByIDs :exec
UPDATE episodes SET monitored = ? WHERE id IN (/*SLICE:ids*/?)
`

type UpdateEpisodesMonitoredByIDsParams struct {
	Monitored int64   `json:"monitored"`
	Ids       []int64 `json:"ids"`
}

func (q *Queries) UpdateEpisodesMonitoredByIDs(ctx context.Context, arg UpdateEpisodesMonitoredByIDsParams) error {
	query := updateEpisodesMonitoredByIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateEpisodesMonitoredBySeason = `-- name: UpdateEpisodesMonitoredBySeason :exec
UPDATE episodes SET monitored = ? WHERE series_id = ? AND season_number = ?
`

type UpdateEpisodesMonitoredBySeasonParams struct {
	Monitored    int64 `json:"monitored"`
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) UpdateEpisodesMonitoredBySeason(ctx context.Context, arg UpdateEpisodesMonitoredBySeasonParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodesMonitoredBySeason, arg.Monitored, arg.SeriesID, arg.SeasonNumber)
	return err
}

const updateEpisodesMonitoredExcludingSeason = `-- name: UpdateEpisodesMonitoredExcludingSeason :exec
UPDATE episodes SET monitored = ? WHERE series_id = ? AND season_number != ?
`

type UpdateEpisodesMonitoredExcludingSeasonParams struct {
	Monitored    int64 `json:"monitored"`
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) UpdateEpisodesMonitoredExcludingSeason(ctx context.Context, arg UpdateEpisodesMonitoredExcludingSeasonParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodesMonitoredExcludingSeason, arg.Monitored, arg.SeriesID, arg.SeasonNumber)
	return err
}

const updateEpisodesMonitoredExcludingSpecials = `-- name: UpdateEpisodesMonitoredExcludingSpecials :exec
UPDATE episodes SET monitored = ? WHERE series_id = ? AND season_number > 0
`

type UpdateEpisodesMonitoredExcludingSpecialsParams struct {
	Monitored int64 `json:"monitored"`
	SeriesID  int64 `json:"series_id"`
}

func (q *Queries) UpdateEpisodesMonitoredExcludingSpecials(ctx context.Context, arg UpdateEpisodesMonitoredExcludingSpecialsParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodesMonitoredExcludingSpecials, arg.Monitored, arg.SeriesID)
	return err
}

const updateEpisodesToUnreleased = `-- name: UpdateEpisodesToUnreleased :execresult
UPDATE episodes SET status = 'unreleased'
WHERE status = 'missing' AND (air_date IS NULL OR substr(air_date, 1, 10) > date('now'))
`

func (q *Queries) UpdateEpisodesToUnreleased(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateEpisodesToUnreleased)
}

const updateFutureEpisodesMonitored = `-- name: UpdateFutureEpisodesMonitored :exec
UPDATE episodes SET monitored = ? WHERE series_id = ? AND status = 'unreleased'
`

type UpdateFutureEpisodesMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	SeriesID  int64 `json:"series_id"`
}

func (q *Queries) UpdateFutureEpisodesMonitored(ctx context.Context, arg UpdateFutureEpisodesMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateFutureEpisodesMonitored, arg.Monitored, arg.SeriesID)
	return err
}

const updateFutureSeasonsMonitored = `-- name: UpdateFutureSeasonsMonitored :exec
UPDATE seasons SET monitored = ?
WHERE seasons.series_id = ? AND seasons.season_number IN (
    SELECT DISTINCT e.season_number FROM episodes e
    WHERE e.series_id = ? AND e.status = 'unreleased'
)
`

type UpdateFutureSeasonsMonitoredParams struct {
	Monitored  int64 `json:"monitored"`
	SeriesID   int64 `json:"series_id"`
	SeriesID_2 int64 `json:"series_id_2"`
}

func (q *Queries) UpdateFutureSeasonsMonitored(ctx context.Context, arg UpdateFutureSeasonsMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateFutureSeasonsMonitored, arg.Monitored, arg.SeriesID, arg.SeriesID_2)
	return err
}

const updateSeason = `-- name: UpdateSeason :one
UPDATE seasons SET monitored = ? WHERE id = ? RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpdateSeasonParams struct {
	Monitored int64 `json:"monitored"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateSeason(ctx context.Context, arg UpdateSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, updateSeason, arg.Monitored, arg.ID)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const updateSeasonMetadata = `-- name: UpdateSeasonMetadata :one
UPDATE seasons SET
    overview = ?,
    poster_url = ?
WHERE id = ?
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpdateSeasonMetadataParams struct {
	Overview  sql.NullString `json:"overview"`
	PosterUrl sql.NullString `json:"poster_url"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateSeasonMetadata(ctx context.Context, arg UpdateSeasonMetadataParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, updateSeasonMetadata, arg.Overview, arg.PosterUrl, arg.ID)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}

const updateSeasonMonitoredByNumber = `-- name: UpdateSeasonMonitoredByNumber :exec
UPDATE seasons SET monitored = ? WHERE series_id = ? AND season_number = ?
`

type UpdateSeasonMonitoredByNumberParams struct {
	Monitored    int64 `json:"monitored"`
	SeriesID     int64 `json:"series_id"`
	SeasonNumber int64 `json:"season_number"`
}

func (q *Queries) UpdateSeasonMonitoredByNumber(ctx context.Context, arg UpdateSeasonMonitoredByNumberParams) error {
	_, err := q.db.ExecContext(ctx, updateSeasonMonitoredByNumber, arg.Monitored, arg.SeriesID, arg.SeasonNumber)
	return err
}

const updateSeasonMonitoredBySeries = `-- name: UpdateSeasonMonitoredBySeries :exec
UPDATE seasons SET monitored = ? WHERE series_id = ?
`

type UpdateSeasonMonitoredBySeriesParams struct {
	Monitored int64 `json:"monitored"`
	SeriesID  int64 `json:"series_id"`
}

func (q *Queries) UpdateSeasonMonitoredBySeries(ctx context.Context, arg UpdateSeasonMonitoredBySeriesParams) error {
	_, err := q.db.ExecContext(ctx, updateSeasonMonitoredBySeries, arg.Monitored, arg.SeriesID)
	return err
}

const updateSeasonMonitoredBySeriesIDs = `-- name: UpdateSeasonMonitoredBySeriesIDs :exec
UPDATE seasons SET monitored = ? WHERE series_id IN (/*SLICE:ids*/?)
`

type UpdateSeasonMonitoredBySeriesIDsParams struct {
	Monitored int64   `json:"monitored"`
	Ids       []int64 `json:"ids"`
}

func (q *Queries) UpdateSeasonMonitoredBySeriesIDs(ctx context.Context, arg UpdateSeasonMonitoredBySeriesIDsParams) error {
	query := updateSeasonMonitoredBySeriesIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateSeasonsMonitoredExcluding = `-- name: UpdateSeasonsMonitoredExcluding :exec
UPDATE seasons SET monitored = ? WHERE series_id = ? AND season_number NOT IN (/*SLICE:excludeSeasons*/?)
`

type UpdateSeasonsMonitoredExcludingParams struct {
	Monitored      int64   `json:"monitored"`
	SeriesID       int64   `json:"series_id"`
	ExcludeSeasons []int64 `json:"excludeSeasons"`
}

func (q *Queries) UpdateSeasonsMonitoredExcluding(ctx context.Context, arg UpdateSeasonsMonitoredExcludingParams) error {
	query := updateSeasonsMonitoredExcluding
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	queryParams = append(queryParams, arg.SeriesID)
	if len(arg.ExcludeSeasons) > 0 {
		for _, v := range arg.ExcludeSeasons {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:excludeSeasons*/?", strings.Repeat(",?", len(arg.ExcludeSeasons))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:excludeSeasons*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateSeasonsMonitoredExcludingSpecials = `-- name: UpdateSeasonsMonitoredExcludingSpecials :exec
UPDATE seasons SET monitored = ? WHERE series_id = ? AND season_number > 0
`

type UpdateSeasonsMonitoredExcludingSpecialsParams struct {
	Monitored int64 `json:"monitored"`
	SeriesID  int64 `json:"series_id"`
}

func (q *Queries) UpdateSeasonsMonitoredExcludingSpecials(ctx context.Context, arg UpdateSeasonsMonitoredExcludingSpecialsParams) error {
	_, err := q.db.ExecContext(ctx, updateSeasonsMonitoredExcludingSpecials, arg.Monitored, arg.SeriesID)
	return err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series SET
    title = ?,
    sort_title = ?,
    year = ?,
    tvdb_id = ?,
    tmdb_id = ?,
    imdb_id = ?,
    overview = ?,
    runtime = ?,
    path = ?,
    root_folder_id = ?,
    quality_profile_id = ?,
    monitored = ?,
    season_folder = ?,
    production_status = ?,
    network = ?,
    format_type = ?,
    network_logo_url = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by
`

type UpdateSeriesParams struct {
	Title            string         `json:"title"`
	SortTitle        string         `json:"sort_title"`
	Year             sql.NullInt64  `json:"year"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	ImdbID           sql.NullString `json:"imdb_id"`
	Overview         sql.NullString `json:"overview"`
	Runtime          sql.NullInt64  `json:"runtime"`
	Path             sql.NullString `json:"path"`
	RootFolderID     sql.NullInt64  `json:"root_folder_id"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
	Monitored        int64          `json:"monitored"`
	SeasonFolder     int64          `json:"season_folder"`
	ProductionStatus string         `json:"production_status"`
	Network          sql.NullString `json:"network"`
	FormatType       sql.NullString `json:"format_type"`
	NetworkLogoUrl   sql.NullString `json:"network_logo_url"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, updateSeries,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.TvdbID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Overview,
		arg.Runtime,
		arg.Path,
		arg.RootFolderID,
		arg.QualityProfileID,
		arg.Monitored,
		arg.SeasonFolder,
		arg.ProductionStatus,
		arg.Network,
		arg.FormatType,
		arg.NetworkLogoUrl,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const updateSeriesFormatType = `-- name: UpdateSeriesFormatType :one
UPDATE series SET format_type = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? RETURNING id, title, sort_title, year, tvdb_id, tmdb_id, imdb_id, overview, runtime, path, root_folder_id, quality_profile_id, monitored, season_folder, production_status, network, format_type, added_at, updated_at, network_logo_url, added_by
`

type UpdateSeriesFormatTypeParams struct {
	FormatType sql.NullString `json:"format_type"`
	ID         int64          `json:"id"`
}

// Format type override queries
func (q *Queries) UpdateSeriesFormatType(ctx context.Context, arg UpdateSeriesFormatTypeParams) (*Series, error) {
	row := q.db.QueryRowContext(ctx, updateSeriesFormatType, arg.FormatType, arg.ID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.TvdbID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Overview,
		&i.Runtime,
		&i.Path,
		&i.RootFolderID,
		&i.QualityProfileID,
		&i.Monitored,
		&i.SeasonFolder,
		&i.ProductionStatus,
		&i.Network,
		&i.FormatType,
		&i.AddedAt,
		&i.UpdatedAt,
		&i.NetworkLogoUrl,
		&i.AddedBy,
	)
	return &i, err
}

const updateSeriesMonitoredByIDs = `-- name: UpdateSeriesMonitoredByIDs :exec
UPDATE series SET monitored = ?, updated_at = CURRENT_TIMESTAMP WHERE id IN (/*SLICE:ids*/?)
`

type UpdateSeriesMonitoredByIDsParams struct {
	Monitored int64   `json:"monitored"`
	Ids       []int64 `json:"ids"`
}

// Bulk monitoring by series IDs (for bulk edit mode)
func (q *Queries) UpdateSeriesMonitoredByIDs(ctx context.Context, arg UpdateSeriesMonitoredByIDsParams) error {
	query := updateSeriesMonitoredByIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Monitored)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateSeriesNetwork = `-- name: UpdateSeriesNetwork :exec
UPDATE series SET network = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateSeriesNetworkParams struct {
	Network sql.NullString `json:"network"`
	ID      int64          `json:"id"`
}

func (q *Queries) UpdateSeriesNetwork(ctx context.Context, arg UpdateSeriesNetworkParams) error {
	_, err := q.db.ExecContext(ctx, updateSeriesNetwork, arg.Network, arg.ID)
	return err
}

const updateSeriesProductionStatus = `-- name: UpdateSeriesProductionStatus :exec
UPDATE series SET production_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateSeriesProductionStatusParams struct {
	ProductionStatus string `json:"production_status"`
	ID               int64  `json:"id"`
}

func (q *Queries) UpdateSeriesProductionStatus(ctx context.Context, arg UpdateSeriesProductionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSeriesProductionStatus, arg.ProductionStatus, arg.ID)
	return err
}

const updateUnreleasedEpisodesToMissing = `-- name: UpdateUnreleasedEpisodesToMissing :execresult
UPDATE episodes SET status = 'missing'
WHERE status = 'unreleased' AND air_date IS NOT NULL
  AND substr(air_date, 1, 10) <= date('now')
`

// Status refresh queries
// Episodes with actual air time (non-midnight): use precise datetime comparison
func (q *Queries) UpdateUnreleasedEpisodesToMissing(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUnreleasedEpisodesToMissing)
}

const updateUnreleasedEpisodesToMissingDateOnly = `-- name: UpdateUnreleasedEpisodesToMissingDateOnly :execresult
UPDATE episodes SET status = 'missing'
WHERE status = 'unreleased' AND air_date IS NOT NULL
  AND substr(air_date, 1, 10) <= date('now')
`

// Kept for backward compatibility; the above query handles all episodes.
// On second call, no rows will match since they were already updated.
func (q *Queries) UpdateUnreleasedEpisodesToMissingDateOnly(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUnreleasedEpisodesToMissingDateOnly)
}

const upsertEpisode = `-- name: UpsertEpisode :one
INSERT INTO episodes (series_id, season_number, episode_number, title, overview, air_date, monitored, status)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(series_id, season_number, episode_number) DO UPDATE SET
    title = COALESCE(excluded.title, episodes.title),
    overview = COALESCE(excluded.overview, episodes.overview),
    air_date = COALESCE(excluded.air_date, episodes.air_date)
RETURNING id, series_id, season_number, episode_number, title, overview, air_date, monitored, status, active_download_id, status_message
`

type UpsertEpisodeParams struct {
	SeriesID      int64          `json:"series_id"`
	SeasonNumber  int64          `json:"season_number"`
	EpisodeNumber int64          `json:"episode_number"`
	Title         sql.NullString `json:"title"`
	Overview      sql.NullString `json:"overview"`
	AirDate       sql.NullTime   `json:"air_date"`
	Monitored     int64          `json:"monitored"`
	Status        string         `json:"status"`
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) (*Episode, error) {
	row := q.db.QueryRowContext(ctx, upsertEpisode,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.Overview,
		arg.AirDate,
		arg.Monitored,
		arg.Status,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.Overview,
		&i.AirDate,
		&i.Monitored,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const upsertSeason = `-- name: UpsertSeason :one
INSERT INTO seasons (series_id, season_number, monitored, overview, poster_url)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(series_id, season_number) DO UPDATE SET
    overview = COALESCE(excluded.overview, seasons.overview),
    poster_url = COALESCE(excluded.poster_url, seasons.poster_url)
RETURNING id, series_id, season_number, monitored, overview, poster_url
`

type UpsertSeasonParams struct {
	SeriesID     int64          `json:"series_id"`
	SeasonNumber int64          `json:"season_number"`
	Monitored    int64          `json:"monitored"`
	Overview     sql.NullString `json:"overview"`
	PosterUrl    sql.NullString `json:"poster_url"`
}

func (q *Queries) UpsertSeason(ctx context.Context, arg UpsertSeasonParams) (*Season, error) {
	row := q.db.QueryRowContext(ctx, upsertSeason,
		arg.SeriesID,
		arg.SeasonNumber,
		arg.Monitored,
		arg.Overview,
		arg.PosterUrl,
	)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.SeasonNumber,
		&i.Monitored,
		&i.Overview,
		&i.PosterUrl,
	)
	return &i, err
}
