// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queue_media.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countQueueMediaByStatus = `-- name: CountQueueMediaByStatus :one
SELECT COUNT(*) FROM queue_media WHERE file_status = ?
`

func (q *Queries) CountQueueMediaByStatus(ctx context.Context, fileStatus string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQueueMediaByStatus, fileStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQueueMedia = `-- name: CreateQueueMedia :one
INSERT INTO queue_media (
    download_mapping_id, episode_id, movie_id, file_path, file_status, target_slot_id
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

type CreateQueueMediaParams struct {
	DownloadMappingID int64          `json:"download_mapping_id"`
	EpisodeID         sql.NullInt64  `json:"episode_id"`
	MovieID           sql.NullInt64  `json:"movie_id"`
	FilePath          sql.NullString `json:"file_path"`
	FileStatus        string         `json:"file_status"`
	TargetSlotID      sql.NullInt64  `json:"target_slot_id"`
}

func (q *Queries) CreateQueueMedia(ctx context.Context, arg CreateQueueMediaParams) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, createQueueMedia,
		arg.DownloadMappingID,
		arg.EpisodeID,
		arg.MovieID,
		arg.FilePath,
		arg.FileStatus,
		arg.TargetSlotID,
	)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const deleteQueueMedia = `-- name: DeleteQueueMedia :exec
DELETE FROM queue_media WHERE id = ?
`

func (q *Queries) DeleteQueueMedia(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQueueMedia, id)
	return err
}

const deleteQueueMediaByDownloadMapping = `-- name: DeleteQueueMediaByDownloadMapping :exec
DELETE FROM queue_media WHERE download_mapping_id = ?
`

func (q *Queries) DeleteQueueMediaByDownloadMapping(ctx context.Context, downloadMappingID int64) error {
	_, err := q.db.ExecContext(ctx, deleteQueueMediaByDownloadMapping, downloadMappingID)
	return err
}

const getFailedQueueMediaWithMapping = `-- name: GetFailedQueueMediaWithMapping :many
SELECT
    qm.id, qm.download_mapping_id, qm.episode_id, qm.movie_id, qm.file_path, qm.file_status, qm.error_message, qm.import_attempts, qm.created_at, qm.updated_at, qm.target_slot_id,
    dm.client_id,
    dm.download_id,
    dm.series_id,
    dm.season_number,
    dm.is_season_pack,
    dm.is_complete_series
FROM queue_media qm
JOIN download_mappings dm ON dm.id = qm.download_mapping_id
WHERE qm.file_status = 'failed'
ORDER BY qm.created_at
`

type GetFailedQueueMediaWithMappingRow struct {
	ID                int64          `json:"id"`
	DownloadMappingID int64          `json:"download_mapping_id"`
	EpisodeID         sql.NullInt64  `json:"episode_id"`
	MovieID           sql.NullInt64  `json:"movie_id"`
	FilePath          sql.NullString `json:"file_path"`
	FileStatus        string         `json:"file_status"`
	ErrorMessage      sql.NullString `json:"error_message"`
	ImportAttempts    int64          `json:"import_attempts"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	TargetSlotID      sql.NullInt64  `json:"target_slot_id"`
	ClientID          int64          `json:"client_id"`
	DownloadID        string         `json:"download_id"`
	SeriesID          sql.NullInt64  `json:"series_id"`
	SeasonNumber      sql.NullInt64  `json:"season_number"`
	IsSeasonPack      int64          `json:"is_season_pack"`
	IsCompleteSeries  int64          `json:"is_complete_series"`
}

func (q *Queries) GetFailedQueueMediaWithMapping(ctx context.Context) ([]*GetFailedQueueMediaWithMappingRow, error) {
	rows, err := q.db.QueryContext(ctx, getFailedQueueMediaWithMapping)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFailedQueueMediaWithMappingRow{}
	for rows.Next() {
		var i GetFailedQueueMediaWithMappingRow
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
			&i.ClientID,
			&i.DownloadID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueMedia = `-- name: GetQueueMedia :one
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media WHERE id = ?
`

func (q *Queries) GetQueueMedia(ctx context.Context, id int64) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, getQueueMedia, id)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const getQueueMediaByDownloadMapping = `-- name: GetQueueMediaByDownloadMapping :many
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media WHERE download_mapping_id = ?
`

func (q *Queries) GetQueueMediaByDownloadMapping(ctx context.Context, downloadMappingID int64) ([]*QueueMedium, error) {
	rows, err := q.db.QueryContext(ctx, getQueueMediaByDownloadMapping, downloadMappingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueueMedium{}
	for rows.Next() {
		var i QueueMedium
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueMediaByEpisode = `-- name: GetQueueMediaByEpisode :one
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media WHERE episode_id = ? LIMIT 1
`

func (q *Queries) GetQueueMediaByEpisode(ctx context.Context, episodeID sql.NullInt64) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, getQueueMediaByEpisode, episodeID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const getQueueMediaByMovie = `-- name: GetQueueMediaByMovie :one
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media WHERE movie_id = ? LIMIT 1
`

func (q *Queries) GetQueueMediaByMovie(ctx context.Context, movieID sql.NullInt64) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, getQueueMediaByMovie, movieID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const getReadyQueueMediaWithMapping = `-- name: GetReadyQueueMediaWithMapping :many
SELECT
    qm.id, qm.download_mapping_id, qm.episode_id, qm.movie_id, qm.file_path, qm.file_status, qm.error_message, qm.import_attempts, qm.created_at, qm.updated_at, qm.target_slot_id,
    dm.client_id,
    dm.download_id,
    dm.series_id,
    dm.season_number,
    dm.is_season_pack,
    dm.is_complete_series
FROM queue_media qm
JOIN download_mappings dm ON dm.id = qm.download_mapping_id
WHERE qm.file_status = 'ready'
ORDER BY qm.created_at
`

type GetReadyQueueMediaWithMappingRow struct {
	ID                int64          `json:"id"`
	DownloadMappingID int64          `json:"download_mapping_id"`
	EpisodeID         sql.NullInt64  `json:"episode_id"`
	MovieID           sql.NullInt64  `json:"movie_id"`
	FilePath          sql.NullString `json:"file_path"`
	FileStatus        string         `json:"file_status"`
	ErrorMessage      sql.NullString `json:"error_message"`
	ImportAttempts    int64          `json:"import_attempts"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	TargetSlotID      sql.NullInt64  `json:"target_slot_id"`
	ClientID          int64          `json:"client_id"`
	DownloadID        string         `json:"download_id"`
	SeriesID          sql.NullInt64  `json:"series_id"`
	SeasonNumber      sql.NullInt64  `json:"season_number"`
	IsSeasonPack      int64          `json:"is_season_pack"`
	IsCompleteSeries  int64          `json:"is_complete_series"`
}

func (q *Queries) GetReadyQueueMediaWithMapping(ctx context.Context) ([]*GetReadyQueueMediaWithMappingRow, error) {
	rows, err := q.db.QueryContext(ctx, getReadyQueueMediaWithMapping)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReadyQueueMediaWithMappingRow{}
	for rows.Next() {
		var i GetReadyQueueMediaWithMappingRow
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
			&i.ClientID,
			&i.DownloadID,
			&i.SeriesID,
			&i.SeasonNumber,
			&i.IsSeasonPack,
			&i.IsCompleteSeries,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementQueueMediaImportAttempts = `-- name: IncrementQueueMediaImportAttempts :one
UPDATE queue_media SET
    import_attempts = import_attempts + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

func (q *Queries) IncrementQueueMediaImportAttempts(ctx context.Context, id int64) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, incrementQueueMediaImportAttempts, id)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const listPendingImports = `-- name: ListPendingImports :many
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media
WHERE file_status IN ('ready', 'failed')
ORDER BY created_at
`

func (q *Queries) ListPendingImports(ctx context.Context) ([]*QueueMedium, error) {
	rows, err := q.db.QueryContext(ctx, listPendingImports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueueMedium{}
	for rows.Next() {
		var i QueueMedium
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingQueueMedia = `-- name: ListPendingQueueMedia :many
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media
WHERE file_status IN ('pending', 'ready', 'importing', 'failed')
ORDER BY created_at DESC
`

func (q *Queries) ListPendingQueueMedia(ctx context.Context) ([]*QueueMedium, error) {
	rows, err := q.db.QueryContext(ctx, listPendingQueueMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueueMedium{}
	for rows.Next() {
		var i QueueMedium
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueueMediaByStatus = `-- name: ListQueueMediaByStatus :many
SELECT id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id FROM queue_media WHERE file_status = ? ORDER BY created_at
`

func (q *Queries) ListQueueMediaByStatus(ctx context.Context, fileStatus string) ([]*QueueMedium, error) {
	rows, err := q.db.QueryContext(ctx, listQueueMediaByStatus, fileStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*QueueMedium{}
	for rows.Next() {
		var i QueueMedium
		if err := rows.Scan(
			&i.ID,
			&i.DownloadMappingID,
			&i.EpisodeID,
			&i.MovieID,
			&i.FilePath,
			&i.FileStatus,
			&i.ErrorMessage,
			&i.ImportAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TargetSlotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetQueueMediaForRetry = `-- name: ResetQueueMediaForRetry :one
UPDATE queue_media SET
    file_status = 'ready',
    error_message = NULL,
    import_attempts = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

func (q *Queries) ResetQueueMediaForRetry(ctx context.Context, id int64) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, resetQueueMediaForRetry, id)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const updateQueueMediaFilePath = `-- name: UpdateQueueMediaFilePath :one
UPDATE queue_media SET
    file_path = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

type UpdateQueueMediaFilePathParams struct {
	FilePath sql.NullString `json:"file_path"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateQueueMediaFilePath(ctx context.Context, arg UpdateQueueMediaFilePathParams) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, updateQueueMediaFilePath, arg.FilePath, arg.ID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const updateQueueMediaSlot = `-- name: UpdateQueueMediaSlot :one
UPDATE queue_media SET
    target_slot_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

type UpdateQueueMediaSlotParams struct {
	TargetSlotID sql.NullInt64 `json:"target_slot_id"`
	ID           int64         `json:"id"`
}

// Req 16.2.3: Per-episode slot assignment for season packs
func (q *Queries) UpdateQueueMediaSlot(ctx context.Context, arg UpdateQueueMediaSlotParams) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, updateQueueMediaSlot, arg.TargetSlotID, arg.ID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const updateQueueMediaStatus = `-- name: UpdateQueueMediaStatus :one
UPDATE queue_media SET
    file_status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

type UpdateQueueMediaStatusParams struct {
	FileStatus string `json:"file_status"`
	ID         int64  `json:"id"`
}

func (q *Queries) UpdateQueueMediaStatus(ctx context.Context, arg UpdateQueueMediaStatusParams) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, updateQueueMediaStatus, arg.FileStatus, arg.ID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}

const updateQueueMediaStatusWithError = `-- name: UpdateQueueMediaStatusWithError :one
UPDATE queue_media SET
    file_status = ?,
    error_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, download_mapping_id, episode_id, movie_id, file_path, file_status, error_message, import_attempts, created_at, updated_at, target_slot_id
`

type UpdateQueueMediaStatusWithErrorParams struct {
	FileStatus   string         `json:"file_status"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateQueueMediaStatusWithError(ctx context.Context, arg UpdateQueueMediaStatusWithErrorParams) (*QueueMedium, error) {
	row := q.db.QueryRowContext(ctx, updateQueueMediaStatusWithError, arg.FileStatus, arg.ErrorMessage, arg.ID)
	var i QueueMedium
	err := row.Scan(
		&i.ID,
		&i.DownloadMappingID,
		&i.EpisodeID,
		&i.MovieID,
		&i.FilePath,
		&i.FileStatus,
		&i.ErrorMessage,
		&i.ImportAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TargetSlotID,
	)
	return &i, err
}
