// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: passkey_credentials.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createPasskeyCredential = `-- name: CreatePasskeyCredential :exec
INSERT INTO passkey_credentials (
    id, user_id, credential_id, public_key, attestation_type,
    transport, flags_user_present, flags_user_verified,
    flags_backup_eligible, flags_backup_state, sign_count, name
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreatePasskeyCredentialParams struct {
	ID                  string         `json:"id"`
	UserID              int64          `json:"user_id"`
	CredentialID        []byte         `json:"credential_id"`
	PublicKey           []byte         `json:"public_key"`
	AttestationType     string         `json:"attestation_type"`
	Transport           sql.NullString `json:"transport"`
	FlagsUserPresent    bool           `json:"flags_user_present"`
	FlagsUserVerified   bool           `json:"flags_user_verified"`
	FlagsBackupEligible bool           `json:"flags_backup_eligible"`
	FlagsBackupState    bool           `json:"flags_backup_state"`
	SignCount           int64          `json:"sign_count"`
	Name                string         `json:"name"`
}

func (q *Queries) CreatePasskeyCredential(ctx context.Context, arg CreatePasskeyCredentialParams) error {
	_, err := q.db.ExecContext(ctx, createPasskeyCredential,
		arg.ID,
		arg.UserID,
		arg.CredentialID,
		arg.PublicKey,
		arg.AttestationType,
		arg.Transport,
		arg.FlagsUserPresent,
		arg.FlagsUserVerified,
		arg.FlagsBackupEligible,
		arg.FlagsBackupState,
		arg.SignCount,
		arg.Name,
	)
	return err
}

const deletePasskeyCredential = `-- name: DeletePasskeyCredential :exec
DELETE FROM passkey_credentials WHERE id = ? AND user_id = ?
`

type DeletePasskeyCredentialParams struct {
	ID     string `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) DeletePasskeyCredential(ctx context.Context, arg DeletePasskeyCredentialParams) error {
	_, err := q.db.ExecContext(ctx, deletePasskeyCredential, arg.ID, arg.UserID)
	return err
}

const getAllPasskeyCredentialsForLogin = `-- name: GetAllPasskeyCredentialsForLogin :many
SELECT pc.id, pc.user_id, pc.credential_id, pc.public_key, pc.attestation_type, pc.transport, pc.flags_user_present, pc.flags_user_verified, pc.flags_backup_eligible, pc.flags_backup_state, pc.sign_count, pc.name, pc.created_at, pc.last_used_at, pu.username, pu.is_admin
FROM passkey_credentials pc
JOIN portal_users pu ON pc.user_id = pu.id
WHERE pu.enabled = 1
`

type GetAllPasskeyCredentialsForLoginRow struct {
	ID                  string         `json:"id"`
	UserID              int64          `json:"user_id"`
	CredentialID        []byte         `json:"credential_id"`
	PublicKey           []byte         `json:"public_key"`
	AttestationType     string         `json:"attestation_type"`
	Transport           sql.NullString `json:"transport"`
	FlagsUserPresent    bool           `json:"flags_user_present"`
	FlagsUserVerified   bool           `json:"flags_user_verified"`
	FlagsBackupEligible bool           `json:"flags_backup_eligible"`
	FlagsBackupState    bool           `json:"flags_backup_state"`
	SignCount           int64          `json:"sign_count"`
	Name                string         `json:"name"`
	CreatedAt           time.Time      `json:"created_at"`
	LastUsedAt          sql.NullTime   `json:"last_used_at"`
	Username            string         `json:"username"`
	IsAdmin             int64          `json:"is_admin"`
}

func (q *Queries) GetAllPasskeyCredentialsForLogin(ctx context.Context) ([]*GetAllPasskeyCredentialsForLoginRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPasskeyCredentialsForLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllPasskeyCredentialsForLoginRow{}
	for rows.Next() {
		var i GetAllPasskeyCredentialsForLoginRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CredentialID,
			&i.PublicKey,
			&i.AttestationType,
			&i.Transport,
			&i.FlagsUserPresent,
			&i.FlagsUserVerified,
			&i.FlagsBackupEligible,
			&i.FlagsBackupState,
			&i.SignCount,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.Username,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasskeyCredentialByCredentialID = `-- name: GetPasskeyCredentialByCredentialID :one
SELECT id, user_id, credential_id, public_key, attestation_type, transport, flags_user_present, flags_user_verified, flags_backup_eligible, flags_backup_state, sign_count, name, created_at, last_used_at FROM passkey_credentials WHERE credential_id = ?
`

func (q *Queries) GetPasskeyCredentialByCredentialID(ctx context.Context, credentialID []byte) (*PasskeyCredential, error) {
	row := q.db.QueryRowContext(ctx, getPasskeyCredentialByCredentialID, credentialID)
	var i PasskeyCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.PublicKey,
		&i.AttestationType,
		&i.Transport,
		&i.FlagsUserPresent,
		&i.FlagsUserVerified,
		&i.FlagsBackupEligible,
		&i.FlagsBackupState,
		&i.SignCount,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return &i, err
}

const getPasskeyCredentialByID = `-- name: GetPasskeyCredentialByID :one
SELECT id, user_id, credential_id, public_key, attestation_type, transport, flags_user_present, flags_user_verified, flags_backup_eligible, flags_backup_state, sign_count, name, created_at, last_used_at FROM passkey_credentials WHERE id = ?
`

func (q *Queries) GetPasskeyCredentialByID(ctx context.Context, id string) (*PasskeyCredential, error) {
	row := q.db.QueryRowContext(ctx, getPasskeyCredentialByID, id)
	var i PasskeyCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CredentialID,
		&i.PublicKey,
		&i.AttestationType,
		&i.Transport,
		&i.FlagsUserPresent,
		&i.FlagsUserVerified,
		&i.FlagsBackupEligible,
		&i.FlagsBackupState,
		&i.SignCount,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return &i, err
}

const getPasskeyCredentialsByUserID = `-- name: GetPasskeyCredentialsByUserID :many
SELECT id, user_id, credential_id, public_key, attestation_type, transport, flags_user_present, flags_user_verified, flags_backup_eligible, flags_backup_state, sign_count, name, created_at, last_used_at FROM passkey_credentials WHERE user_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetPasskeyCredentialsByUserID(ctx context.Context, userID int64) ([]*PasskeyCredential, error) {
	rows, err := q.db.QueryContext(ctx, getPasskeyCredentialsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PasskeyCredential{}
	for rows.Next() {
		var i PasskeyCredential
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CredentialID,
			&i.PublicKey,
			&i.AttestationType,
			&i.Transport,
			&i.FlagsUserPresent,
			&i.FlagsUserVerified,
			&i.FlagsBackupEligible,
			&i.FlagsBackupState,
			&i.SignCount,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePasskeyCredentialName = `-- name: UpdatePasskeyCredentialName :exec
UPDATE passkey_credentials SET name = ? WHERE id = ? AND user_id = ?
`

type UpdatePasskeyCredentialNameParams struct {
	Name   string `json:"name"`
	ID     string `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) UpdatePasskeyCredentialName(ctx context.Context, arg UpdatePasskeyCredentialNameParams) error {
	_, err := q.db.ExecContext(ctx, updatePasskeyCredentialName, arg.Name, arg.ID, arg.UserID)
	return err
}

const updatePasskeyCredentialSignCount = `-- name: UpdatePasskeyCredentialSignCount :exec
UPDATE passkey_credentials
SET sign_count = ?, last_used_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdatePasskeyCredentialSignCountParams struct {
	SignCount int64  `json:"sign_count"`
	ID        string `json:"id"`
}

func (q *Queries) UpdatePasskeyCredentialSignCount(ctx context.Context, arg UpdatePasskeyCredentialSignCountParams) error {
	_, err := q.db.ExecContext(ctx, updatePasskeyCredentialSignCount, arg.SignCount, arg.ID)
	return err
}
