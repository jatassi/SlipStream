// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: slots.sql

package sqlc

import (
	"context"
	"database/sql"
)

const clearAllEpisodeFileSlotsForSlot = `-- name: ClearAllEpisodeFileSlotsForSlot :exec
UPDATE episode_files SET slot_id = NULL WHERE slot_id = ?
`

func (q *Queries) ClearAllEpisodeFileSlotsForSlot(ctx context.Context, slotID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, clearAllEpisodeFileSlotsForSlot, slotID)
	return err
}

const clearAllEpisodeSlotAssignmentsForSlot = `-- name: ClearAllEpisodeSlotAssignmentsForSlot :exec
UPDATE episode_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE slot_id = ?
`

func (q *Queries) ClearAllEpisodeSlotAssignmentsForSlot(ctx context.Context, slotID int64) error {
	_, err := q.db.ExecContext(ctx, clearAllEpisodeSlotAssignmentsForSlot, slotID)
	return err
}

const clearAllMovieFileSlotsForSlot = `-- name: ClearAllMovieFileSlotsForSlot :exec
UPDATE movie_files SET slot_id = NULL WHERE slot_id = ?
`

func (q *Queries) ClearAllMovieFileSlotsForSlot(ctx context.Context, slotID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, clearAllMovieFileSlotsForSlot, slotID)
	return err
}

const clearAllMovieSlotAssignmentsForSlot = `-- name: ClearAllMovieSlotAssignmentsForSlot :exec
UPDATE movie_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE slot_id = ?
`

func (q *Queries) ClearAllMovieSlotAssignmentsForSlot(ctx context.Context, slotID int64) error {
	_, err := q.db.ExecContext(ctx, clearAllMovieSlotAssignmentsForSlot, slotID)
	return err
}

const clearEpisodeFileSlot = `-- name: ClearEpisodeFileSlot :exec
UPDATE episode_files SET slot_id = NULL WHERE id = ?
`

func (q *Queries) ClearEpisodeFileSlot(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, clearEpisodeFileSlot, id)
	return err
}

const clearEpisodeSlotFile = `-- name: ClearEpisodeSlotFile :exec
UPDATE episode_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
`

type ClearEpisodeSlotFileParams struct {
	EpisodeID int64 `json:"episode_id"`
	SlotID    int64 `json:"slot_id"`
}

func (q *Queries) ClearEpisodeSlotFile(ctx context.Context, arg ClearEpisodeSlotFileParams) error {
	_, err := q.db.ExecContext(ctx, clearEpisodeSlotFile, arg.EpisodeID, arg.SlotID)
	return err
}

const clearEpisodeSlotFileByFileID = `-- name: ClearEpisodeSlotFileByFileID :exec
UPDATE episode_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE file_id = ?
`

func (q *Queries) ClearEpisodeSlotFileByFileID(ctx context.Context, fileID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, clearEpisodeSlotFileByFileID, fileID)
	return err
}

const clearMovieFileSlot = `-- name: ClearMovieFileSlot :exec
UPDATE movie_files SET slot_id = NULL WHERE id = ?
`

func (q *Queries) ClearMovieFileSlot(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, clearMovieFileSlot, id)
	return err
}

const clearMovieSlotFile = `-- name: ClearMovieSlotFile :exec
UPDATE movie_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
`

type ClearMovieSlotFileParams struct {
	MovieID int64 `json:"movie_id"`
	SlotID  int64 `json:"slot_id"`
}

func (q *Queries) ClearMovieSlotFile(ctx context.Context, arg ClearMovieSlotFileParams) error {
	_, err := q.db.ExecContext(ctx, clearMovieSlotFile, arg.MovieID, arg.SlotID)
	return err
}

const clearMovieSlotFileByFileID = `-- name: ClearMovieSlotFileByFileID :exec
UPDATE movie_slot_assignments SET
    file_id = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE file_id = ?
`

func (q *Queries) ClearMovieSlotFileByFileID(ctx context.Context, fileID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, clearMovieSlotFileByFileID, fileID)
	return err
}

const countAllFilesInSlot = `-- name: CountAllFilesInSlot :one
SELECT
    (SELECT COUNT(*) FROM movie_files mf WHERE mf.slot_id = ?) +
    (SELECT COUNT(*) FROM episode_files ef WHERE ef.slot_id = ?) as total_count
`

type CountAllFilesInSlotParams struct {
	SlotID   sql.NullInt64 `json:"slot_id"`
	SlotID_2 sql.NullInt64 `json:"slot_id_2"`
}

// Combined File Counts
func (q *Queries) CountAllFilesInSlot(ctx context.Context, arg CountAllFilesInSlotParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllFilesInSlot, arg.SlotID, arg.SlotID_2)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countEpisodeFilesInSlot = `-- name: CountEpisodeFilesInSlot :one
SELECT COUNT(*) FROM episode_files WHERE slot_id = ?
`

func (q *Queries) CountEpisodeFilesInSlot(ctx context.Context, slotID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesInSlot, slotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeFilesWithoutSlot = `-- name: CountEpisodeFilesWithoutSlot :one
SELECT COUNT(*) FROM episode_files WHERE slot_id IS NULL
`

func (q *Queries) CountEpisodeFilesWithoutSlot(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeFilesWithoutSlot)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodeSlotAssignmentsForSlot = `-- name: CountEpisodeSlotAssignmentsForSlot :one
SELECT COUNT(*) FROM episode_slot_assignments WHERE slot_id = ?
`

func (q *Queries) CountEpisodeSlotAssignmentsForSlot(ctx context.Context, slotID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEpisodeSlotAssignmentsForSlot, slotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFilesInSlot = `-- name: CountMovieFilesInSlot :one
SELECT COUNT(*) FROM movie_files WHERE slot_id = ?
`

func (q *Queries) CountMovieFilesInSlot(ctx context.Context, slotID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFilesInSlot, slotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieFilesWithoutSlot = `-- name: CountMovieFilesWithoutSlot :one

SELECT COUNT(*) FROM movie_files WHERE slot_id IS NULL
`

// =====================
// Review Queue Queries
// =====================
func (q *Queries) CountMovieFilesWithoutSlot(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieFilesWithoutSlot)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovieSlotAssignmentsForSlot = `-- name: CountMovieSlotAssignmentsForSlot :one
SELECT COUNT(*) FROM movie_slot_assignments WHERE slot_id = ?
`

func (q *Queries) CountMovieSlotAssignmentsForSlot(ctx context.Context, slotID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMovieSlotAssignmentsForSlot, slotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSlotsUsingProfile = `-- name: CountSlotsUsingProfile :one
SELECT COUNT(*) FROM version_slots WHERE quality_profile_id = ?
`

func (q *Queries) CountSlotsUsingProfile(ctx context.Context, qualityProfileID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSlotsUsingProfile, qualityProfileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEpisodeSlotAssignment = `-- name: CreateEpisodeSlotAssignment :one
INSERT INTO episode_slot_assignments (episode_id, slot_id, file_id, monitored, status)
VALUES (?, ?, ?, ?, ?)
RETURNING id, episode_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type CreateEpisodeSlotAssignmentParams struct {
	EpisodeID int64         `json:"episode_id"`
	SlotID    int64         `json:"slot_id"`
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	Status    string        `json:"status"`
}

func (q *Queries) CreateEpisodeSlotAssignment(ctx context.Context, arg CreateEpisodeSlotAssignmentParams) (*EpisodeSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, createEpisodeSlotAssignment,
		arg.EpisodeID,
		arg.SlotID,
		arg.FileID,
		arg.Monitored,
		arg.Status,
	)
	var i EpisodeSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const createMovieSlotAssignment = `-- name: CreateMovieSlotAssignment :one
INSERT INTO movie_slot_assignments (movie_id, slot_id, file_id, monitored, status)
VALUES (?, ?, ?, ?, ?)
RETURNING id, movie_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type CreateMovieSlotAssignmentParams struct {
	MovieID   int64         `json:"movie_id"`
	SlotID    int64         `json:"slot_id"`
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	Status    string        `json:"status"`
}

func (q *Queries) CreateMovieSlotAssignment(ctx context.Context, arg CreateMovieSlotAssignmentParams) (*MovieSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, createMovieSlotAssignment,
		arg.MovieID,
		arg.SlotID,
		arg.FileID,
		arg.Monitored,
		arg.Status,
	)
	var i MovieSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const deleteEpisodeSlotAssignment = `-- name: DeleteEpisodeSlotAssignment :exec
DELETE FROM episode_slot_assignments WHERE episode_id = ? AND slot_id = ?
`

type DeleteEpisodeSlotAssignmentParams struct {
	EpisodeID int64 `json:"episode_id"`
	SlotID    int64 `json:"slot_id"`
}

func (q *Queries) DeleteEpisodeSlotAssignment(ctx context.Context, arg DeleteEpisodeSlotAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeSlotAssignment, arg.EpisodeID, arg.SlotID)
	return err
}

const deleteEpisodeSlotAssignments = `-- name: DeleteEpisodeSlotAssignments :exec
DELETE FROM episode_slot_assignments WHERE episode_id = ?
`

func (q *Queries) DeleteEpisodeSlotAssignments(ctx context.Context, episodeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisodeSlotAssignments, episodeID)
	return err
}

const deleteMovieSlotAssignment = `-- name: DeleteMovieSlotAssignment :exec
DELETE FROM movie_slot_assignments WHERE movie_id = ? AND slot_id = ?
`

type DeleteMovieSlotAssignmentParams struct {
	MovieID int64 `json:"movie_id"`
	SlotID  int64 `json:"slot_id"`
}

func (q *Queries) DeleteMovieSlotAssignment(ctx context.Context, arg DeleteMovieSlotAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteMovieSlotAssignment, arg.MovieID, arg.SlotID)
	return err
}

const deleteMovieSlotAssignments = `-- name: DeleteMovieSlotAssignments :exec
DELETE FROM movie_slot_assignments WHERE movie_id = ?
`

func (q *Queries) DeleteMovieSlotAssignments(ctx context.Context, movieID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMovieSlotAssignments, movieID)
	return err
}

const getEpisodeFileSlotAssignments = `-- name: GetEpisodeFileSlotAssignments :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, vs.name as slot_name, vs.slot_number
FROM episode_files ef
LEFT JOIN version_slots vs ON ef.slot_id = vs.id
WHERE ef.episode_id = ?
ORDER BY vs.slot_number
`

type GetEpisodeFileSlotAssignmentsRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	SlotName         sql.NullString `json:"slot_name"`
	SlotNumber       sql.NullInt64  `json:"slot_number"`
}

// Episode File Slot Assignments
func (q *Queries) GetEpisodeFileSlotAssignments(ctx context.Context, episodeID int64) ([]*GetEpisodeFileSlotAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeFileSlotAssignments, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEpisodeFileSlotAssignmentsRow{}
	for rows.Next() {
		var i GetEpisodeFileSlotAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.SlotName,
			&i.SlotNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeSlotAssignment = `-- name: GetEpisodeSlotAssignment :one

SELECT id, episode_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message FROM episode_slot_assignments WHERE episode_id = ? AND slot_id = ? LIMIT 1
`

type GetEpisodeSlotAssignmentParams struct {
	EpisodeID int64 `json:"episode_id"`
	SlotID    int64 `json:"slot_id"`
}

// =====================
// Episode Slot Assignments
// =====================
func (q *Queries) GetEpisodeSlotAssignment(ctx context.Context, arg GetEpisodeSlotAssignmentParams) (*EpisodeSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeSlotAssignment, arg.EpisodeID, arg.SlotID)
	var i EpisodeSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getEpisodeSlotAssignmentByFileID = `-- name: GetEpisodeSlotAssignmentByFileID :one
SELECT id, episode_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message FROM episode_slot_assignments WHERE file_id = ? LIMIT 1
`

func (q *Queries) GetEpisodeSlotAssignmentByFileID(ctx context.Context, fileID sql.NullInt64) (*EpisodeSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeSlotAssignmentByFileID, fileID)
	var i EpisodeSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getMovieFileSlotAssignments = `-- name: GetMovieFileSlotAssignments :many
SELECT mf.id, mf.movie_id, mf.path, mf.size, mf.quality, mf.video_codec, mf.audio_codec, mf.resolution, mf.created_at, mf.quality_id, mf.original_path, mf.original_filename, mf.imported_at, mf.slot_id, vs.name as slot_name, vs.slot_number
FROM movie_files mf
LEFT JOIN version_slots vs ON mf.slot_id = vs.id
WHERE mf.movie_id = ?
ORDER BY vs.slot_number
`

type GetMovieFileSlotAssignmentsRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	SlotName         sql.NullString `json:"slot_name"`
	SlotNumber       sql.NullInt64  `json:"slot_number"`
}

// Movie File Slot Assignments
func (q *Queries) GetMovieFileSlotAssignments(ctx context.Context, movieID int64) ([]*GetMovieFileSlotAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMovieFileSlotAssignments, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMovieFileSlotAssignmentsRow{}
	for rows.Next() {
		var i GetMovieFileSlotAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.SlotName,
			&i.SlotNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieSlotAssignment = `-- name: GetMovieSlotAssignment :one

SELECT id, movie_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message FROM movie_slot_assignments WHERE movie_id = ? AND slot_id = ? LIMIT 1
`

type GetMovieSlotAssignmentParams struct {
	MovieID int64 `json:"movie_id"`
	SlotID  int64 `json:"slot_id"`
}

// =====================
// Movie Slot Assignments
// =====================
func (q *Queries) GetMovieSlotAssignment(ctx context.Context, arg GetMovieSlotAssignmentParams) (*MovieSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, getMovieSlotAssignment, arg.MovieID, arg.SlotID)
	var i MovieSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getMovieSlotAssignmentByFileID = `-- name: GetMovieSlotAssignmentByFileID :one

SELECT id, movie_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message FROM movie_slot_assignments WHERE file_id = ? LIMIT 1
`

// =====================
// File Deletion Queries
// =====================
func (q *Queries) GetMovieSlotAssignmentByFileID(ctx context.Context, fileID sql.NullInt64) (*MovieSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, getMovieSlotAssignmentByFileID, fileID)
	var i MovieSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const getMultiVersionSettings = `-- name: GetMultiVersionSettings :one
SELECT id, enabled, dry_run_completed, last_migration_at, created_at, updated_at FROM multi_version_settings WHERE id = 1 LIMIT 1
`

// Multi-Version Settings
func (q *Queries) GetMultiVersionSettings(ctx context.Context) (*MultiVersionSetting, error) {
	row := q.db.QueryRowContext(ctx, getMultiVersionSettings)
	var i MultiVersionSetting
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.DryRunCompleted,
		&i.LastMigrationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVersionSlot = `-- name: GetVersionSlot :one
SELECT id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id FROM version_slots WHERE id = ? LIMIT 1
`

// Version Slots
func (q *Queries) GetVersionSlot(ctx context.Context, id int64) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, getVersionSlot, id)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const getVersionSlotByNumber = `-- name: GetVersionSlotByNumber :one
SELECT id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id FROM version_slots WHERE slot_number = ? LIMIT 1
`

func (q *Queries) GetVersionSlotByNumber(ctx context.Context, slotNumber int64) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, getVersionSlotByNumber, slotNumber)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const listEnabledVersionSlots = `-- name: ListEnabledVersionSlots :many
SELECT id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id FROM version_slots WHERE enabled = 1 ORDER BY display_order
`

func (q *Queries) ListEnabledVersionSlots(ctx context.Context) ([]*VersionSlot, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledVersionSlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VersionSlot{}
	for rows.Next() {
		var i VersionSlot
		if err := rows.Scan(
			&i.ID,
			&i.SlotNumber,
			&i.Name,
			&i.Enabled,
			&i.QualityProfileID,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MovieRootFolderID,
			&i.TvRootFolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledVersionSlotsWithProfiles = `-- name: ListEnabledVersionSlotsWithProfiles :many
SELECT
    vs.id, vs.slot_number, vs.name, vs.enabled, vs.quality_profile_id, vs.display_order, vs.created_at, vs.updated_at, vs.movie_root_folder_id, vs.tv_root_folder_id,
    qp.id as profile_id,
    qp.name as profile_name,
    qp.cutoff as profile_cutoff,
    qp.items as profile_items,
    qp.hdr_settings as profile_hdr_settings,
    qp.video_codec_settings as profile_video_codec_settings,
    qp.audio_codec_settings as profile_audio_codec_settings,
    qp.audio_channel_settings as profile_audio_channel_settings
FROM version_slots vs
LEFT JOIN quality_profiles qp ON vs.quality_profile_id = qp.id
WHERE vs.enabled = 1
ORDER BY vs.display_order
`

type ListEnabledVersionSlotsWithProfilesRow struct {
	ID                          int64          `json:"id"`
	SlotNumber                  int64          `json:"slot_number"`
	Name                        string         `json:"name"`
	Enabled                     int64          `json:"enabled"`
	QualityProfileID            sql.NullInt64  `json:"quality_profile_id"`
	DisplayOrder                int64          `json:"display_order"`
	CreatedAt                   sql.NullTime   `json:"created_at"`
	UpdatedAt                   sql.NullTime   `json:"updated_at"`
	MovieRootFolderID           sql.NullInt64  `json:"movie_root_folder_id"`
	TvRootFolderID              sql.NullInt64  `json:"tv_root_folder_id"`
	ProfileID                   sql.NullInt64  `json:"profile_id"`
	ProfileName                 sql.NullString `json:"profile_name"`
	ProfileCutoff               sql.NullInt64  `json:"profile_cutoff"`
	ProfileItems                sql.NullString `json:"profile_items"`
	ProfileHdrSettings          sql.NullString `json:"profile_hdr_settings"`
	ProfileVideoCodecSettings   sql.NullString `json:"profile_video_codec_settings"`
	ProfileAudioCodecSettings   sql.NullString `json:"profile_audio_codec_settings"`
	ProfileAudioChannelSettings sql.NullString `json:"profile_audio_channel_settings"`
}

func (q *Queries) ListEnabledVersionSlotsWithProfiles(ctx context.Context) ([]*ListEnabledVersionSlotsWithProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledVersionSlotsWithProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEnabledVersionSlotsWithProfilesRow{}
	for rows.Next() {
		var i ListEnabledVersionSlotsWithProfilesRow
		if err := rows.Scan(
			&i.ID,
			&i.SlotNumber,
			&i.Name,
			&i.Enabled,
			&i.QualityProfileID,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MovieRootFolderID,
			&i.TvRootFolderID,
			&i.ProfileID,
			&i.ProfileName,
			&i.ProfileCutoff,
			&i.ProfileItems,
			&i.ProfileHdrSettings,
			&i.ProfileVideoCodecSettings,
			&i.ProfileAudioCodecSettings,
			&i.ProfileAudioChannelSettings,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesInSlot = `-- name: ListEpisodeFilesInSlot :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, e.title as episode_title, e.season_number, e.episode_number, s.title as series_title
FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ef.slot_id = ?
ORDER BY s.title, e.season_number, e.episode_number
`

type ListEpisodeFilesInSlotRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	EpisodeTitle     sql.NullString `json:"episode_title"`
	SeasonNumber     int64          `json:"season_number"`
	EpisodeNumber    int64          `json:"episode_number"`
	SeriesTitle      string         `json:"series_title"`
}

func (q *Queries) ListEpisodeFilesInSlot(ctx context.Context, slotID sql.NullInt64) ([]*ListEpisodeFilesInSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesInSlot, slotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeFilesInSlotRow{}
	for rows.Next() {
		var i ListEpisodeFilesInSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.SeriesTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeFilesWithoutSlot = `-- name: ListEpisodeFilesWithoutSlot :many
SELECT ef.id, ef.episode_id, ef.path, ef.size, ef.quality, ef.video_codec, ef.audio_codec, ef.resolution, ef.created_at, ef.quality_id, ef.original_path, ef.original_filename, ef.imported_at, ef.slot_id, e.title as episode_title, e.season_number, e.episode_number, s.title as series_title
FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ef.slot_id IS NULL
ORDER BY s.title, e.season_number, e.episode_number
`

type ListEpisodeFilesWithoutSlotRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	EpisodeTitle     sql.NullString `json:"episode_title"`
	SeasonNumber     int64          `json:"season_number"`
	EpisodeNumber    int64          `json:"episode_number"`
	SeriesTitle      string         `json:"series_title"`
}

func (q *Queries) ListEpisodeFilesWithoutSlot(ctx context.Context) ([]*ListEpisodeFilesWithoutSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeFilesWithoutSlot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeFilesWithoutSlotRow{}
	for rows.Next() {
		var i ListEpisodeFilesWithoutSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.SeriesTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeSlotAssignments = `-- name: ListEpisodeSlotAssignments :many
SELECT esa.id, esa.episode_id, esa.slot_id, esa.file_id, esa.monitored, esa.created_at, esa.updated_at, esa.status, esa.active_download_id, esa.status_message, vs.name as slot_name, vs.slot_number, vs.quality_profile_id
FROM episode_slot_assignments esa
JOIN version_slots vs ON esa.slot_id = vs.id
WHERE esa.episode_id = ?
ORDER BY vs.slot_number
`

type ListEpisodeSlotAssignmentsRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	SlotName         string         `json:"slot_name"`
	SlotNumber       int64          `json:"slot_number"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
}

func (q *Queries) ListEpisodeSlotAssignments(ctx context.Context, episodeID int64) ([]*ListEpisodeSlotAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeSlotAssignments, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeSlotAssignmentsRow{}
	for rows.Next() {
		var i ListEpisodeSlotAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SlotName,
			&i.SlotNumber,
			&i.QualityProfileID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeSlotAssignmentsForSlot = `-- name: ListEpisodeSlotAssignmentsForSlot :many
SELECT esa.id, esa.episode_id, esa.slot_id, esa.file_id, esa.monitored, esa.created_at, esa.updated_at, esa.status, esa.active_download_id, esa.status_message, e.title as episode_title, e.season_number, e.episode_number, s.title as series_title
FROM episode_slot_assignments esa
JOIN episodes e ON esa.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE esa.slot_id = ?
ORDER BY s.title, e.season_number, e.episode_number
`

type ListEpisodeSlotAssignmentsForSlotRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	EpisodeTitle     sql.NullString `json:"episode_title"`
	SeasonNumber     int64          `json:"season_number"`
	EpisodeNumber    int64          `json:"episode_number"`
	SeriesTitle      string         `json:"series_title"`
}

func (q *Queries) ListEpisodeSlotAssignmentsForSlot(ctx context.Context, slotID int64) ([]*ListEpisodeSlotAssignmentsForSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeSlotAssignmentsForSlot, slotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeSlotAssignmentsForSlotRow{}
	for rows.Next() {
		var i ListEpisodeSlotAssignmentsForSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.EpisodeTitle,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.SeriesTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeSlotAssignmentsWithFilesForProfile = `-- name: ListEpisodeSlotAssignmentsWithFilesForProfile :many
SELECT esa.episode_id, esa.slot_id, esa.status, esa.file_id, ef.quality_id as current_quality_id
FROM episode_slot_assignments esa
JOIN episode_files ef ON esa.file_id = ef.id
JOIN version_slots vs ON esa.slot_id = vs.id
WHERE vs.quality_profile_id = ?
  AND esa.status IN ('available', 'upgradable')
  AND ef.quality_id IS NOT NULL
`

type ListEpisodeSlotAssignmentsWithFilesForProfileRow struct {
	EpisodeID        int64         `json:"episode_id"`
	SlotID           int64         `json:"slot_id"`
	Status           string        `json:"status"`
	FileID           sql.NullInt64 `json:"file_id"`
	CurrentQualityID sql.NullInt64 `json:"current_quality_id"`
}

func (q *Queries) ListEpisodeSlotAssignmentsWithFilesForProfile(ctx context.Context, qualityProfileID sql.NullInt64) ([]*ListEpisodeSlotAssignmentsWithFilesForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeSlotAssignmentsWithFilesForProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeSlotAssignmentsWithFilesForProfileRow{}
	for rows.Next() {
		var i ListEpisodeSlotAssignmentsWithFilesForProfileRow
		if err := rows.Scan(
			&i.EpisodeID,
			&i.SlotID,
			&i.Status,
			&i.FileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodeSlotsNeedingSearch = `-- name: ListEpisodeSlotsNeedingSearch :many
SELECT esa.id, esa.episode_id, esa.slot_id, esa.file_id, esa.monitored, esa.created_at, esa.updated_at, esa.status, esa.active_download_id, esa.status_message, vs.name as slot_name, vs.slot_number, vs.quality_profile_id
FROM episode_slot_assignments esa
JOIN version_slots vs ON esa.slot_id = vs.id
WHERE esa.episode_id = ?
  AND esa.monitored = 1
  AND esa.status IN ('missing', 'upgradable')
ORDER BY vs.slot_number
`

type ListEpisodeSlotsNeedingSearchRow struct {
	ID               int64          `json:"id"`
	EpisodeID        int64          `json:"episode_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	SlotName         string         `json:"slot_name"`
	SlotNumber       int64          `json:"slot_number"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
}

func (q *Queries) ListEpisodeSlotsNeedingSearch(ctx context.Context, episodeID int64) ([]*ListEpisodeSlotsNeedingSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, listEpisodeSlotsNeedingSearch, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEpisodeSlotsNeedingSearchRow{}
	for rows.Next() {
		var i ListEpisodeSlotsNeedingSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SlotName,
			&i.SlotNumber,
			&i.QualityProfileID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesAssignedToSlot = `-- name: ListFilesAssignedToSlot :many

SELECT
    'movie' as media_type,
    mf.id as file_id,
    mf.path as file_path,
    mf.movie_id as media_id,
    m.title as media_title
FROM movie_files mf
JOIN movies m ON mf.movie_id = m.id
WHERE mf.slot_id = ?
UNION ALL
SELECT
    'episode' as media_type,
    ef.id as file_id,
    ef.path as file_path,
    ef.episode_id as media_id,
    s.title || ' S' || printf('%02d', e.season_number) || 'E' || printf('%02d', e.episode_number) as media_title
FROM episode_files ef
JOIN episodes e ON ef.episode_id = e.id
JOIN series s ON e.series_id = s.id
WHERE ef.slot_id = ?
ORDER BY media_title
`

type ListFilesAssignedToSlotParams struct {
	SlotID   sql.NullInt64 `json:"slot_id"`
	SlotID_2 sql.NullInt64 `json:"slot_id_2"`
}

type ListFilesAssignedToSlotRow struct {
	MediaType  string `json:"media_type"`
	FileID     int64  `json:"file_id"`
	FilePath   string `json:"file_path"`
	MediaID    int64  `json:"media_id"`
	MediaTitle string `json:"media_title"`
}

// =====================
// Slot Disable Queries
// =====================
func (q *Queries) ListFilesAssignedToSlot(ctx context.Context, arg ListFilesAssignedToSlotParams) ([]*ListFilesAssignedToSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listFilesAssignedToSlot, arg.SlotID, arg.SlotID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListFilesAssignedToSlotRow{}
	for rows.Next() {
		var i ListFilesAssignedToSlotRow
		if err := rows.Scan(
			&i.MediaType,
			&i.FileID,
			&i.FilePath,
			&i.MediaID,
			&i.MediaTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredEpisodeSlotStatuses = `-- name: ListMonitoredEpisodeSlotStatuses :many
SELECT esa.status FROM episode_slot_assignments esa
WHERE esa.episode_id = ? AND esa.monitored = 1
`

func (q *Queries) ListMonitoredEpisodeSlotStatuses(ctx context.Context, episodeID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredEpisodeSlotStatuses, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var status string
		if err := rows.Scan(&status); err != nil {
			return nil, err
		}
		items = append(items, status)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitoredMovieSlotStatuses = `-- name: ListMonitoredMovieSlotStatuses :many
SELECT msa.status FROM movie_slot_assignments msa
WHERE msa.movie_id = ? AND msa.monitored = 1
`

// Slot status queries for cached aggregate computation
func (q *Queries) ListMonitoredMovieSlotStatuses(ctx context.Context, movieID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listMonitoredMovieSlotStatuses, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var status string
		if err := rows.Scan(&status); err != nil {
			return nil, err
		}
		items = append(items, status)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFilesInSlot = `-- name: ListMovieFilesInSlot :many
SELECT mf.id, mf.movie_id, mf.path, mf.size, mf.quality, mf.video_codec, mf.audio_codec, mf.resolution, mf.created_at, mf.quality_id, mf.original_path, mf.original_filename, mf.imported_at, mf.slot_id, m.title as movie_title
FROM movie_files mf
JOIN movies m ON mf.movie_id = m.id
WHERE mf.slot_id = ?
ORDER BY m.title
`

type ListMovieFilesInSlotRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	MovieTitle       string         `json:"movie_title"`
}

func (q *Queries) ListMovieFilesInSlot(ctx context.Context, slotID sql.NullInt64) ([]*ListMovieFilesInSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFilesInSlot, slotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieFilesInSlotRow{}
	for rows.Next() {
		var i ListMovieFilesInSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.MovieTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieFilesWithoutSlot = `-- name: ListMovieFilesWithoutSlot :many
SELECT mf.id, mf.movie_id, mf.path, mf.size, mf.quality, mf.video_codec, mf.audio_codec, mf.resolution, mf.created_at, mf.quality_id, mf.original_path, mf.original_filename, mf.imported_at, mf.slot_id, m.title as movie_title
FROM movie_files mf
JOIN movies m ON mf.movie_id = m.id
WHERE mf.slot_id IS NULL
ORDER BY m.title
`

type ListMovieFilesWithoutSlotRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	Path             string         `json:"path"`
	Size             int64          `json:"size"`
	Quality          sql.NullString `json:"quality"`
	VideoCodec       sql.NullString `json:"video_codec"`
	AudioCodec       sql.NullString `json:"audio_codec"`
	Resolution       sql.NullString `json:"resolution"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	QualityID        sql.NullInt64  `json:"quality_id"`
	OriginalPath     sql.NullString `json:"original_path"`
	OriginalFilename sql.NullString `json:"original_filename"`
	ImportedAt       sql.NullTime   `json:"imported_at"`
	SlotID           sql.NullInt64  `json:"slot_id"`
	MovieTitle       string         `json:"movie_title"`
}

func (q *Queries) ListMovieFilesWithoutSlot(ctx context.Context) ([]*ListMovieFilesWithoutSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieFilesWithoutSlot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieFilesWithoutSlotRow{}
	for rows.Next() {
		var i ListMovieFilesWithoutSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.Path,
			&i.Size,
			&i.Quality,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Resolution,
			&i.CreatedAt,
			&i.QualityID,
			&i.OriginalPath,
			&i.OriginalFilename,
			&i.ImportedAt,
			&i.SlotID,
			&i.MovieTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieSlotAssignments = `-- name: ListMovieSlotAssignments :many
SELECT msa.id, msa.movie_id, msa.slot_id, msa.file_id, msa.monitored, msa.created_at, msa.updated_at, msa.status, msa.active_download_id, msa.status_message, vs.name as slot_name, vs.slot_number, vs.quality_profile_id
FROM movie_slot_assignments msa
JOIN version_slots vs ON msa.slot_id = vs.id
WHERE msa.movie_id = ?
ORDER BY vs.slot_number
`

type ListMovieSlotAssignmentsRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	SlotName         string         `json:"slot_name"`
	SlotNumber       int64          `json:"slot_number"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
}

func (q *Queries) ListMovieSlotAssignments(ctx context.Context, movieID int64) ([]*ListMovieSlotAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieSlotAssignments, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieSlotAssignmentsRow{}
	for rows.Next() {
		var i ListMovieSlotAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SlotName,
			&i.SlotNumber,
			&i.QualityProfileID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieSlotAssignmentsForSlot = `-- name: ListMovieSlotAssignmentsForSlot :many
SELECT msa.id, msa.movie_id, msa.slot_id, msa.file_id, msa.monitored, msa.created_at, msa.updated_at, msa.status, msa.active_download_id, msa.status_message, m.title as movie_title
FROM movie_slot_assignments msa
JOIN movies m ON msa.movie_id = m.id
WHERE msa.slot_id = ?
ORDER BY m.title
`

type ListMovieSlotAssignmentsForSlotRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	MovieTitle       string         `json:"movie_title"`
}

func (q *Queries) ListMovieSlotAssignmentsForSlot(ctx context.Context, slotID int64) ([]*ListMovieSlotAssignmentsForSlotRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieSlotAssignmentsForSlot, slotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieSlotAssignmentsForSlotRow{}
	for rows.Next() {
		var i ListMovieSlotAssignmentsForSlotRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.MovieTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieSlotAssignmentsWithFilesForProfile = `-- name: ListMovieSlotAssignmentsWithFilesForProfile :many
SELECT msa.movie_id, msa.slot_id, msa.status, msa.file_id, mf.quality_id as current_quality_id
FROM movie_slot_assignments msa
JOIN movie_files mf ON msa.file_id = mf.id
JOIN version_slots vs ON msa.slot_id = vs.id
WHERE vs.quality_profile_id = ?
  AND msa.status IN ('available', 'upgradable')
  AND mf.quality_id IS NOT NULL
`

type ListMovieSlotAssignmentsWithFilesForProfileRow struct {
	MovieID          int64         `json:"movie_id"`
	SlotID           int64         `json:"slot_id"`
	Status           string        `json:"status"`
	FileID           sql.NullInt64 `json:"file_id"`
	CurrentQualityID sql.NullInt64 `json:"current_quality_id"`
}

// Slot-level quality recalculation
func (q *Queries) ListMovieSlotAssignmentsWithFilesForProfile(ctx context.Context, qualityProfileID sql.NullInt64) ([]*ListMovieSlotAssignmentsWithFilesForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieSlotAssignmentsWithFilesForProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieSlotAssignmentsWithFilesForProfileRow{}
	for rows.Next() {
		var i ListMovieSlotAssignmentsWithFilesForProfileRow
		if err := rows.Scan(
			&i.MovieID,
			&i.SlotID,
			&i.Status,
			&i.FileID,
			&i.CurrentQualityID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovieSlotsNeedingSearch = `-- name: ListMovieSlotsNeedingSearch :many
SELECT msa.id, msa.movie_id, msa.slot_id, msa.file_id, msa.monitored, msa.created_at, msa.updated_at, msa.status, msa.active_download_id, msa.status_message, vs.name as slot_name, vs.slot_number, vs.quality_profile_id
FROM movie_slot_assignments msa
JOIN version_slots vs ON msa.slot_id = vs.id
WHERE msa.movie_id = ?
  AND msa.monitored = 1
  AND msa.status IN ('missing', 'upgradable')
ORDER BY vs.slot_number
`

type ListMovieSlotsNeedingSearchRow struct {
	ID               int64          `json:"id"`
	MovieID          int64          `json:"movie_id"`
	SlotID           int64          `json:"slot_id"`
	FileID           sql.NullInt64  `json:"file_id"`
	Monitored        int64          `json:"monitored"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	SlotName         string         `json:"slot_name"`
	SlotNumber       int64          `json:"slot_number"`
	QualityProfileID sql.NullInt64  `json:"quality_profile_id"`
}

// Slot-level search: find slots needing search
func (q *Queries) ListMovieSlotsNeedingSearch(ctx context.Context, movieID int64) ([]*ListMovieSlotsNeedingSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, listMovieSlotsNeedingSearch, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMovieSlotsNeedingSearchRow{}
	for rows.Next() {
		var i ListMovieSlotsNeedingSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.SlotID,
			&i.FileID,
			&i.Monitored,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.SlotName,
			&i.SlotNumber,
			&i.QualityProfileID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesMissingInMonitoredSlots = `-- name: ListMoviesMissingInMonitoredSlots :many

SELECT DISTINCT m.id, m.title, m.sort_title, m.year, m.tmdb_id, m.imdb_id, m.overview, m.runtime, m.path, m.root_folder_id, m.quality_profile_id, m.monitored, m.status, m.active_download_id, m.status_message, m.release_date, m.physical_release_date, m.added_at, m.updated_at, m.theatrical_release_date
FROM movies m
CROSS JOIN version_slots vs
LEFT JOIN movie_slot_assignments msa ON m.id = msa.movie_id AND vs.id = msa.slot_id
WHERE vs.enabled = 1
  AND m.monitored = 1
  AND (msa.monitored = 1 OR msa.monitored IS NULL)
  AND (msa.file_id IS NULL OR msa.id IS NULL)
`

// =====================
// Status Queries
// =====================
func (q *Queries) ListMoviesMissingInMonitoredSlots(ctx context.Context) ([]*Movie, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesMissingInMonitoredSlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.TmdbID,
			&i.ImdbID,
			&i.Overview,
			&i.Runtime,
			&i.Path,
			&i.RootFolderID,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.ActiveDownloadID,
			&i.StatusMessage,
			&i.ReleaseDate,
			&i.PhysicalReleaseDate,
			&i.AddedAt,
			&i.UpdatedAt,
			&i.TheatricalReleaseDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVersionSlots = `-- name: ListVersionSlots :many
SELECT id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id FROM version_slots ORDER BY display_order
`

func (q *Queries) ListVersionSlots(ctx context.Context) ([]*VersionSlot, error) {
	rows, err := q.db.QueryContext(ctx, listVersionSlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VersionSlot{}
	for rows.Next() {
		var i VersionSlot
		if err := rows.Scan(
			&i.ID,
			&i.SlotNumber,
			&i.Name,
			&i.Enabled,
			&i.QualityProfileID,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MovieRootFolderID,
			&i.TvRootFolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVersionSlotsWithProfiles = `-- name: ListVersionSlotsWithProfiles :many
SELECT
    vs.id, vs.slot_number, vs.name, vs.enabled, vs.quality_profile_id, vs.display_order, vs.created_at, vs.updated_at, vs.movie_root_folder_id, vs.tv_root_folder_id,
    qp.id as profile_id,
    qp.name as profile_name,
    qp.cutoff as profile_cutoff,
    qp.items as profile_items,
    qp.hdr_settings as profile_hdr_settings,
    qp.video_codec_settings as profile_video_codec_settings,
    qp.audio_codec_settings as profile_audio_codec_settings,
    qp.audio_channel_settings as profile_audio_channel_settings
FROM version_slots vs
LEFT JOIN quality_profiles qp ON vs.quality_profile_id = qp.id
ORDER BY vs.display_order
`

type ListVersionSlotsWithProfilesRow struct {
	ID                          int64          `json:"id"`
	SlotNumber                  int64          `json:"slot_number"`
	Name                        string         `json:"name"`
	Enabled                     int64          `json:"enabled"`
	QualityProfileID            sql.NullInt64  `json:"quality_profile_id"`
	DisplayOrder                int64          `json:"display_order"`
	CreatedAt                   sql.NullTime   `json:"created_at"`
	UpdatedAt                   sql.NullTime   `json:"updated_at"`
	MovieRootFolderID           sql.NullInt64  `json:"movie_root_folder_id"`
	TvRootFolderID              sql.NullInt64  `json:"tv_root_folder_id"`
	ProfileID                   sql.NullInt64  `json:"profile_id"`
	ProfileName                 sql.NullString `json:"profile_name"`
	ProfileCutoff               sql.NullInt64  `json:"profile_cutoff"`
	ProfileItems                sql.NullString `json:"profile_items"`
	ProfileHdrSettings          sql.NullString `json:"profile_hdr_settings"`
	ProfileVideoCodecSettings   sql.NullString `json:"profile_video_codec_settings"`
	ProfileAudioCodecSettings   sql.NullString `json:"profile_audio_codec_settings"`
	ProfileAudioChannelSettings sql.NullString `json:"profile_audio_channel_settings"`
}

// Slot with Profile (for joined queries)
func (q *Queries) ListVersionSlotsWithProfiles(ctx context.Context) ([]*ListVersionSlotsWithProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listVersionSlotsWithProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVersionSlotsWithProfilesRow{}
	for rows.Next() {
		var i ListVersionSlotsWithProfilesRow
		if err := rows.Scan(
			&i.ID,
			&i.SlotNumber,
			&i.Name,
			&i.Enabled,
			&i.QualityProfileID,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MovieRootFolderID,
			&i.TvRootFolderID,
			&i.ProfileID,
			&i.ProfileName,
			&i.ProfileCutoff,
			&i.ProfileItems,
			&i.ProfileHdrSettings,
			&i.ProfileVideoCodecSettings,
			&i.ProfileAudioCodecSettings,
			&i.ProfileAudioChannelSettings,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDryRunCompleted = `-- name: SetDryRunCompleted :one
UPDATE multi_version_settings SET
    dry_run_completed = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, enabled, dry_run_completed, last_migration_at, created_at, updated_at
`

func (q *Queries) SetDryRunCompleted(ctx context.Context, dryRunCompleted int64) (*MultiVersionSetting, error) {
	row := q.db.QueryRowContext(ctx, setDryRunCompleted, dryRunCompleted)
	var i MultiVersionSetting
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.DryRunCompleted,
		&i.LastMigrationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const setMultiVersionEnabled = `-- name: SetMultiVersionEnabled :one
UPDATE multi_version_settings SET
    enabled = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, enabled, dry_run_completed, last_migration_at, created_at, updated_at
`

func (q *Queries) SetMultiVersionEnabled(ctx context.Context, enabled int64) (*MultiVersionSetting, error) {
	row := q.db.QueryRowContext(ctx, setMultiVersionEnabled, enabled)
	var i MultiVersionSetting
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.DryRunCompleted,
		&i.LastMigrationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateAllEpisodeSlotStatuses = `-- name: UpdateAllEpisodeSlotStatuses :exec
UPDATE episode_slot_assignments SET
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ?
`

type UpdateAllEpisodeSlotStatusesParams struct {
	Status    string `json:"status"`
	EpisodeID int64  `json:"episode_id"`
}

func (q *Queries) UpdateAllEpisodeSlotStatuses(ctx context.Context, arg UpdateAllEpisodeSlotStatusesParams) error {
	_, err := q.db.ExecContext(ctx, updateAllEpisodeSlotStatuses, arg.Status, arg.EpisodeID)
	return err
}

const updateAllMovieSlotStatuses = `-- name: UpdateAllMovieSlotStatuses :exec
UPDATE movie_slot_assignments SET
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ?
`

type UpdateAllMovieSlotStatusesParams struct {
	Status  string `json:"status"`
	MovieID int64  `json:"movie_id"`
}

// Bulk status updates for unreleased/missing transitions (affects all slots for an item)
func (q *Queries) UpdateAllMovieSlotStatuses(ctx context.Context, arg UpdateAllMovieSlotStatusesParams) error {
	_, err := q.db.ExecContext(ctx, updateAllMovieSlotStatuses, arg.Status, arg.MovieID)
	return err
}

const updateEpisodeFileSlot = `-- name: UpdateEpisodeFileSlot :one
UPDATE episode_files SET slot_id = ? WHERE id = ? RETURNING id, episode_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type UpdateEpisodeFileSlotParams struct {
	SlotID sql.NullInt64 `json:"slot_id"`
	ID     int64         `json:"id"`
}

func (q *Queries) UpdateEpisodeFileSlot(ctx context.Context, arg UpdateEpisodeFileSlotParams) (*EpisodeFile, error) {
	row := q.db.QueryRowContext(ctx, updateEpisodeFileSlot, arg.SlotID, arg.ID)
	var i EpisodeFile
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const updateEpisodeSlotAssignment = `-- name: UpdateEpisodeSlotAssignment :one
UPDATE episode_slot_assignments SET
    file_id = ?,
    monitored = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
RETURNING id, episode_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type UpdateEpisodeSlotAssignmentParams struct {
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	EpisodeID int64         `json:"episode_id"`
	SlotID    int64         `json:"slot_id"`
}

func (q *Queries) UpdateEpisodeSlotAssignment(ctx context.Context, arg UpdateEpisodeSlotAssignmentParams) (*EpisodeSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, updateEpisodeSlotAssignment,
		arg.FileID,
		arg.Monitored,
		arg.EpisodeID,
		arg.SlotID,
	)
	var i EpisodeSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const updateEpisodeSlotFile = `-- name: UpdateEpisodeSlotFile :exec
UPDATE episode_slot_assignments SET
    file_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
`

type UpdateEpisodeSlotFileParams struct {
	FileID    sql.NullInt64 `json:"file_id"`
	EpisodeID int64         `json:"episode_id"`
	SlotID    int64         `json:"slot_id"`
}

func (q *Queries) UpdateEpisodeSlotFile(ctx context.Context, arg UpdateEpisodeSlotFileParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeSlotFile, arg.FileID, arg.EpisodeID, arg.SlotID)
	return err
}

const updateEpisodeSlotMonitored = `-- name: UpdateEpisodeSlotMonitored :exec
UPDATE episode_slot_assignments SET
    monitored = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
`

type UpdateEpisodeSlotMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	EpisodeID int64 `json:"episode_id"`
	SlotID    int64 `json:"slot_id"`
}

func (q *Queries) UpdateEpisodeSlotMonitored(ctx context.Context, arg UpdateEpisodeSlotMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeSlotMonitored, arg.Monitored, arg.EpisodeID, arg.SlotID)
	return err
}

const updateEpisodeSlotStatus = `-- name: UpdateEpisodeSlotStatus :exec
UPDATE episode_slot_assignments SET
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
`

type UpdateEpisodeSlotStatusParams struct {
	Status    string `json:"status"`
	EpisodeID int64  `json:"episode_id"`
	SlotID    int64  `json:"slot_id"`
}

func (q *Queries) UpdateEpisodeSlotStatus(ctx context.Context, arg UpdateEpisodeSlotStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeSlotStatus, arg.Status, arg.EpisodeID, arg.SlotID)
	return err
}

const updateEpisodeSlotStatusWithDetails = `-- name: UpdateEpisodeSlotStatusWithDetails :exec
UPDATE episode_slot_assignments SET
    status = ?,
    active_download_id = ?,
    status_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE episode_id = ? AND slot_id = ?
`

type UpdateEpisodeSlotStatusWithDetailsParams struct {
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	EpisodeID        int64          `json:"episode_id"`
	SlotID           int64          `json:"slot_id"`
}

func (q *Queries) UpdateEpisodeSlotStatusWithDetails(ctx context.Context, arg UpdateEpisodeSlotStatusWithDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeSlotStatusWithDetails,
		arg.Status,
		arg.ActiveDownloadID,
		arg.StatusMessage,
		arg.EpisodeID,
		arg.SlotID,
	)
	return err
}

const updateMovieFileSlot = `-- name: UpdateMovieFileSlot :one
UPDATE movie_files SET slot_id = ? WHERE id = ? RETURNING id, movie_id, path, size, quality, video_codec, audio_codec, resolution, created_at, quality_id, original_path, original_filename, imported_at, slot_id
`

type UpdateMovieFileSlotParams struct {
	SlotID sql.NullInt64 `json:"slot_id"`
	ID     int64         `json:"id"`
}

func (q *Queries) UpdateMovieFileSlot(ctx context.Context, arg UpdateMovieFileSlotParams) (*MovieFile, error) {
	row := q.db.QueryRowContext(ctx, updateMovieFileSlot, arg.SlotID, arg.ID)
	var i MovieFile
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.Path,
		&i.Size,
		&i.Quality,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Resolution,
		&i.CreatedAt,
		&i.QualityID,
		&i.OriginalPath,
		&i.OriginalFilename,
		&i.ImportedAt,
		&i.SlotID,
	)
	return &i, err
}

const updateMovieSlotAssignment = `-- name: UpdateMovieSlotAssignment :one
UPDATE movie_slot_assignments SET
    file_id = ?,
    monitored = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
RETURNING id, movie_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type UpdateMovieSlotAssignmentParams struct {
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	MovieID   int64         `json:"movie_id"`
	SlotID    int64         `json:"slot_id"`
}

func (q *Queries) UpdateMovieSlotAssignment(ctx context.Context, arg UpdateMovieSlotAssignmentParams) (*MovieSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, updateMovieSlotAssignment,
		arg.FileID,
		arg.Monitored,
		arg.MovieID,
		arg.SlotID,
	)
	var i MovieSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const updateMovieSlotFile = `-- name: UpdateMovieSlotFile :exec
UPDATE movie_slot_assignments SET
    file_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
`

type UpdateMovieSlotFileParams struct {
	FileID  sql.NullInt64 `json:"file_id"`
	MovieID int64         `json:"movie_id"`
	SlotID  int64         `json:"slot_id"`
}

func (q *Queries) UpdateMovieSlotFile(ctx context.Context, arg UpdateMovieSlotFileParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieSlotFile, arg.FileID, arg.MovieID, arg.SlotID)
	return err
}

const updateMovieSlotMonitored = `-- name: UpdateMovieSlotMonitored :exec
UPDATE movie_slot_assignments SET
    monitored = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
`

type UpdateMovieSlotMonitoredParams struct {
	Monitored int64 `json:"monitored"`
	MovieID   int64 `json:"movie_id"`
	SlotID    int64 `json:"slot_id"`
}

func (q *Queries) UpdateMovieSlotMonitored(ctx context.Context, arg UpdateMovieSlotMonitoredParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieSlotMonitored, arg.Monitored, arg.MovieID, arg.SlotID)
	return err
}

const updateMovieSlotStatus = `-- name: UpdateMovieSlotStatus :exec
UPDATE movie_slot_assignments SET
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
`

type UpdateMovieSlotStatusParams struct {
	Status  string `json:"status"`
	MovieID int64  `json:"movie_id"`
	SlotID  int64  `json:"slot_id"`
}

func (q *Queries) UpdateMovieSlotStatus(ctx context.Context, arg UpdateMovieSlotStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieSlotStatus, arg.Status, arg.MovieID, arg.SlotID)
	return err
}

const updateMovieSlotStatusWithDetails = `-- name: UpdateMovieSlotStatusWithDetails :exec
UPDATE movie_slot_assignments SET
    status = ?,
    active_download_id = ?,
    status_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE movie_id = ? AND slot_id = ?
`

type UpdateMovieSlotStatusWithDetailsParams struct {
	Status           string         `json:"status"`
	ActiveDownloadID sql.NullString `json:"active_download_id"`
	StatusMessage    sql.NullString `json:"status_message"`
	MovieID          int64          `json:"movie_id"`
	SlotID           int64          `json:"slot_id"`
}

func (q *Queries) UpdateMovieSlotStatusWithDetails(ctx context.Context, arg UpdateMovieSlotStatusWithDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateMovieSlotStatusWithDetails,
		arg.Status,
		arg.ActiveDownloadID,
		arg.StatusMessage,
		arg.MovieID,
		arg.SlotID,
	)
	return err
}

const updateMultiVersionSettings = `-- name: UpdateMultiVersionSettings :one
UPDATE multi_version_settings SET
    enabled = ?,
    dry_run_completed = ?,
    last_migration_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, enabled, dry_run_completed, last_migration_at, created_at, updated_at
`

type UpdateMultiVersionSettingsParams struct {
	Enabled         int64        `json:"enabled"`
	DryRunCompleted int64        `json:"dry_run_completed"`
	LastMigrationAt sql.NullTime `json:"last_migration_at"`
}

func (q *Queries) UpdateMultiVersionSettings(ctx context.Context, arg UpdateMultiVersionSettingsParams) (*MultiVersionSetting, error) {
	row := q.db.QueryRowContext(ctx, updateMultiVersionSettings, arg.Enabled, arg.DryRunCompleted, arg.LastMigrationAt)
	var i MultiVersionSetting
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.DryRunCompleted,
		&i.LastMigrationAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateVersionSlot = `-- name: UpdateVersionSlot :one
UPDATE version_slots SET
    name = ?,
    enabled = ?,
    quality_profile_id = ?,
    display_order = ?,
    movie_root_folder_id = ?,
    tv_root_folder_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id
`

type UpdateVersionSlotParams struct {
	Name              string        `json:"name"`
	Enabled           int64         `json:"enabled"`
	QualityProfileID  sql.NullInt64 `json:"quality_profile_id"`
	DisplayOrder      int64         `json:"display_order"`
	MovieRootFolderID sql.NullInt64 `json:"movie_root_folder_id"`
	TvRootFolderID    sql.NullInt64 `json:"tv_root_folder_id"`
	ID                int64         `json:"id"`
}

func (q *Queries) UpdateVersionSlot(ctx context.Context, arg UpdateVersionSlotParams) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, updateVersionSlot,
		arg.Name,
		arg.Enabled,
		arg.QualityProfileID,
		arg.DisplayOrder,
		arg.MovieRootFolderID,
		arg.TvRootFolderID,
		arg.ID,
	)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const updateVersionSlotEnabled = `-- name: UpdateVersionSlotEnabled :one
UPDATE version_slots SET
    enabled = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id
`

type UpdateVersionSlotEnabledParams struct {
	Enabled int64 `json:"enabled"`
	ID      int64 `json:"id"`
}

func (q *Queries) UpdateVersionSlotEnabled(ctx context.Context, arg UpdateVersionSlotEnabledParams) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, updateVersionSlotEnabled, arg.Enabled, arg.ID)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const updateVersionSlotName = `-- name: UpdateVersionSlotName :one
UPDATE version_slots SET
    name = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id
`

type UpdateVersionSlotNameParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateVersionSlotName(ctx context.Context, arg UpdateVersionSlotNameParams) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, updateVersionSlotName, arg.Name, arg.ID)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const updateVersionSlotProfile = `-- name: UpdateVersionSlotProfile :one
UPDATE version_slots SET
    quality_profile_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id
`

type UpdateVersionSlotProfileParams struct {
	QualityProfileID sql.NullInt64 `json:"quality_profile_id"`
	ID               int64         `json:"id"`
}

func (q *Queries) UpdateVersionSlotProfile(ctx context.Context, arg UpdateVersionSlotProfileParams) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, updateVersionSlotProfile, arg.QualityProfileID, arg.ID)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const updateVersionSlotRootFolders = `-- name: UpdateVersionSlotRootFolders :one
UPDATE version_slots SET
    movie_root_folder_id = ?,
    tv_root_folder_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slot_number, name, enabled, quality_profile_id, display_order, created_at, updated_at, movie_root_folder_id, tv_root_folder_id
`

type UpdateVersionSlotRootFoldersParams struct {
	MovieRootFolderID sql.NullInt64 `json:"movie_root_folder_id"`
	TvRootFolderID    sql.NullInt64 `json:"tv_root_folder_id"`
	ID                int64         `json:"id"`
}

func (q *Queries) UpdateVersionSlotRootFolders(ctx context.Context, arg UpdateVersionSlotRootFoldersParams) (*VersionSlot, error) {
	row := q.db.QueryRowContext(ctx, updateVersionSlotRootFolders, arg.MovieRootFolderID, arg.TvRootFolderID, arg.ID)
	var i VersionSlot
	err := row.Scan(
		&i.ID,
		&i.SlotNumber,
		&i.Name,
		&i.Enabled,
		&i.QualityProfileID,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MovieRootFolderID,
		&i.TvRootFolderID,
	)
	return &i, err
}

const upsertEpisodeSlotAssignment = `-- name: UpsertEpisodeSlotAssignment :one
INSERT INTO episode_slot_assignments (episode_id, slot_id, file_id, monitored, status)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (episode_id, slot_id) DO UPDATE SET
    file_id = excluded.file_id,
    monitored = excluded.monitored,
    status = excluded.status,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, episode_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type UpsertEpisodeSlotAssignmentParams struct {
	EpisodeID int64         `json:"episode_id"`
	SlotID    int64         `json:"slot_id"`
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	Status    string        `json:"status"`
}

func (q *Queries) UpsertEpisodeSlotAssignment(ctx context.Context, arg UpsertEpisodeSlotAssignmentParams) (*EpisodeSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, upsertEpisodeSlotAssignment,
		arg.EpisodeID,
		arg.SlotID,
		arg.FileID,
		arg.Monitored,
		arg.Status,
	)
	var i EpisodeSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}

const upsertMovieSlotAssignment = `-- name: UpsertMovieSlotAssignment :one
INSERT INTO movie_slot_assignments (movie_id, slot_id, file_id, monitored, status)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (movie_id, slot_id) DO UPDATE SET
    file_id = excluded.file_id,
    monitored = excluded.monitored,
    status = excluded.status,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, movie_id, slot_id, file_id, monitored, created_at, updated_at, status, active_download_id, status_message
`

type UpsertMovieSlotAssignmentParams struct {
	MovieID   int64         `json:"movie_id"`
	SlotID    int64         `json:"slot_id"`
	FileID    sql.NullInt64 `json:"file_id"`
	Monitored int64         `json:"monitored"`
	Status    string        `json:"status"`
}

func (q *Queries) UpsertMovieSlotAssignment(ctx context.Context, arg UpsertMovieSlotAssignmentParams) (*MovieSlotAssignment, error) {
	row := q.db.QueryRowContext(ctx, upsertMovieSlotAssignment,
		arg.MovieID,
		arg.SlotID,
		arg.FileID,
		arg.Monitored,
		arg.Status,
	)
	var i MovieSlotAssignment
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.SlotID,
		&i.FileID,
		&i.Monitored,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.ActiveDownloadID,
		&i.StatusMessage,
	)
	return &i, err
}
