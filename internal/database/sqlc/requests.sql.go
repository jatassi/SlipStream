// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: requests.sql

package sqlc

import (
	"context"
	"database/sql"
)

const approveRequest = `-- name: ApproveRequest :one
UPDATE requests SET
    status = 'approved',
    approved_at = CURRENT_TIMESTAMP,
    approved_by = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at
`

type ApproveRequestParams struct {
	ApprovedBy sql.NullInt64 `json:"approved_by"`
	ID         int64         `json:"id"`
}

func (q *Queries) ApproveRequest(ctx context.Context, arg ApproveRequestParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, approveRequest, arg.ApprovedBy, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const countRequests = `-- name: CountRequests :one
SELECT COUNT(*) FROM requests
`

func (q *Queries) CountRequests(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRequests)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestsByStatus = `-- name: CountRequestsByStatus :one
SELECT COUNT(*) FROM requests WHERE status = ?
`

func (q *Queries) CountRequestsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRequestsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestsByUser = `-- name: CountRequestsByUser :one
SELECT COUNT(*) FROM requests WHERE user_id = ?
`

func (q *Queries) CountRequestsByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRequestsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAutoApprovedInPeriod = `-- name: CountUserAutoApprovedInPeriod :one
SELECT COUNT(*) FROM requests
WHERE user_id = ?
  AND media_type = ?
  AND approved_at >= ?
  AND approved_by IS NULL
`

type CountUserAutoApprovedInPeriodParams struct {
	UserID     int64        `json:"user_id"`
	MediaType  string       `json:"media_type"`
	ApprovedAt sql.NullTime `json:"approved_at"`
}

func (q *Queries) CountUserAutoApprovedInPeriod(ctx context.Context, arg CountUserAutoApprovedInPeriodParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserAutoApprovedInPeriod, arg.UserID, arg.MediaType, arg.ApprovedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO requests (
    user_id, media_type, tmdb_id, tvdb_id, title, year,
    season_number, episode_number, status, monitor_type, target_slot_id, poster_url, requested_seasons
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at
`

type CreateRequestParams struct {
	UserID           int64          `json:"user_id"`
	MediaType        string         `json:"media_type"`
	TmdbID           sql.NullInt64  `json:"tmdb_id"`
	TvdbID           sql.NullInt64  `json:"tvdb_id"`
	Title            string         `json:"title"`
	Year             sql.NullInt64  `json:"year"`
	SeasonNumber     sql.NullInt64  `json:"season_number"`
	EpisodeNumber    sql.NullInt64  `json:"episode_number"`
	Status           string         `json:"status"`
	MonitorType      sql.NullString `json:"monitor_type"`
	TargetSlotID     sql.NullInt64  `json:"target_slot_id"`
	PosterUrl        sql.NullString `json:"poster_url"`
	RequestedSeasons sql.NullString `json:"requested_seasons"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, createRequest,
		arg.UserID,
		arg.MediaType,
		arg.TmdbID,
		arg.TvdbID,
		arg.Title,
		arg.Year,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Status,
		arg.MonitorType,
		arg.TargetSlotID,
		arg.PosterUrl,
		arg.RequestedSeasons,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE FROM requests WHERE id = ?
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const denyRequest = `-- name: DenyRequest :one
UPDATE requests SET
    status = 'denied',
    denied_reason = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at
`

type DenyRequestParams struct {
	DeniedReason sql.NullString `json:"denied_reason"`
	ID           int64          `json:"id"`
}

func (q *Queries) DenyRequest(ctx context.Context, arg DenyRequestParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, denyRequest, arg.DeniedReason, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getActiveRequestByTmdbID = `-- name: GetActiveRequestByTmdbID :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tmdb_id = ? AND media_type = ? AND status NOT IN ('denied', 'cancelled')
LIMIT 1
`

type GetActiveRequestByTmdbIDParams struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	MediaType string        `json:"media_type"`
}

// Used for availability display - includes 'available' status to show completed requests
func (q *Queries) GetActiveRequestByTmdbID(ctx context.Context, arg GetActiveRequestByTmdbIDParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getActiveRequestByTmdbID, arg.TmdbID, arg.MediaType)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getActiveRequestByTvdbID = `-- name: GetActiveRequestByTvdbID :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = ? AND status NOT IN ('denied', 'cancelled')
LIMIT 1
`

type GetActiveRequestByTvdbIDParams struct {
	TvdbID    sql.NullInt64 `json:"tvdb_id"`
	MediaType string        `json:"media_type"`
}

// Used for availability display - includes 'available' status to show completed requests
func (q *Queries) GetActiveRequestByTvdbID(ctx context.Context, arg GetActiveRequestByTvdbIDParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getActiveRequestByTvdbID, arg.TvdbID, arg.MediaType)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getActiveRequestByTvdbIDAndEpisode = `-- name: GetActiveRequestByTvdbIDAndEpisode :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = 'episode' AND season_number = ? AND episode_number = ? AND status NOT IN ('denied', 'cancelled')
LIMIT 1
`

type GetActiveRequestByTvdbIDAndEpisodeParams struct {
	TvdbID        sql.NullInt64 `json:"tvdb_id"`
	SeasonNumber  sql.NullInt64 `json:"season_number"`
	EpisodeNumber sql.NullInt64 `json:"episode_number"`
}

// Used for availability display - includes 'available' status to show completed requests
func (q *Queries) GetActiveRequestByTvdbIDAndEpisode(ctx context.Context, arg GetActiveRequestByTvdbIDAndEpisodeParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getActiveRequestByTvdbIDAndEpisode, arg.TvdbID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getActiveRequestByTvdbIDAndSeason = `-- name: GetActiveRequestByTvdbIDAndSeason :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = 'season' AND season_number = ? AND status NOT IN ('denied', 'cancelled')
LIMIT 1
`

type GetActiveRequestByTvdbIDAndSeasonParams struct {
	TvdbID       sql.NullInt64 `json:"tvdb_id"`
	SeasonNumber sql.NullInt64 `json:"season_number"`
}

// Used for availability display - includes 'available' status to show completed requests
func (q *Queries) GetActiveRequestByTvdbIDAndSeason(ctx context.Context, arg GetActiveRequestByTvdbIDAndSeasonParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getActiveRequestByTvdbIDAndSeason, arg.TvdbID, arg.SeasonNumber)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRequest = `-- name: GetRequest :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests WHERE id = ? LIMIT 1
`

func (q *Queries) GetRequest(ctx context.Context, id int64) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getRequest, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRequestByTmdbID = `-- name: GetRequestByTmdbID :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tmdb_id = ? AND media_type = ? AND status NOT IN ('denied', 'available')
LIMIT 1
`

type GetRequestByTmdbIDParams struct {
	TmdbID    sql.NullInt64 `json:"tmdb_id"`
	MediaType string        `json:"media_type"`
}

func (q *Queries) GetRequestByTmdbID(ctx context.Context, arg GetRequestByTmdbIDParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestByTmdbID, arg.TmdbID, arg.MediaType)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRequestByTvdbID = `-- name: GetRequestByTvdbID :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = ? AND status NOT IN ('denied', 'available')
LIMIT 1
`

type GetRequestByTvdbIDParams struct {
	TvdbID    sql.NullInt64 `json:"tvdb_id"`
	MediaType string        `json:"media_type"`
}

func (q *Queries) GetRequestByTvdbID(ctx context.Context, arg GetRequestByTvdbIDParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestByTvdbID, arg.TvdbID, arg.MediaType)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRequestByTvdbIDAndEpisode = `-- name: GetRequestByTvdbIDAndEpisode :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = 'episode' AND season_number = ? AND episode_number = ? AND status NOT IN ('denied', 'available')
LIMIT 1
`

type GetRequestByTvdbIDAndEpisodeParams struct {
	TvdbID        sql.NullInt64 `json:"tvdb_id"`
	SeasonNumber  sql.NullInt64 `json:"season_number"`
	EpisodeNumber sql.NullInt64 `json:"episode_number"`
}

func (q *Queries) GetRequestByTvdbIDAndEpisode(ctx context.Context, arg GetRequestByTvdbIDAndEpisodeParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestByTvdbIDAndEpisode, arg.TvdbID, arg.SeasonNumber, arg.EpisodeNumber)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRequestByTvdbIDAndSeason = `-- name: GetRequestByTvdbIDAndSeason :one
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = 'season' AND season_number = ? AND status NOT IN ('denied', 'available')
LIMIT 1
`

type GetRequestByTvdbIDAndSeasonParams struct {
	TvdbID       sql.NullInt64 `json:"tvdb_id"`
	SeasonNumber sql.NullInt64 `json:"season_number"`
}

func (q *Queries) GetRequestByTvdbIDAndSeason(ctx context.Context, arg GetRequestByTvdbIDAndSeasonParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestByTvdbIDAndSeason, arg.TvdbID, arg.SeasonNumber)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const linkRequestToMedia = `-- name: LinkRequestToMedia :one
UPDATE requests SET
    media_id = ?,
    status = 'available',
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at
`

type LinkRequestToMediaParams struct {
	MediaID sql.NullInt64 `json:"media_id"`
	ID      int64         `json:"id"`
}

func (q *Queries) LinkRequestToMedia(ctx context.Context, arg LinkRequestToMediaParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, linkRequestToMedia, arg.MediaID, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listActiveSeriesRequestsByTvdbID = `-- name: ListActiveSeriesRequestsByTvdbID :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE tvdb_id = ? AND media_type = 'series' AND status IN ('downloading', 'approved')
ORDER BY created_at DESC
`

// Used for status tracking - find active series requests by TVDB ID
func (q *Queries) ListActiveSeriesRequestsByTvdbID(ctx context.Context, tvdbID sql.NullInt64) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSeriesRequestsByTvdbID, tvdbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingRequests = `-- name: ListPendingRequests :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) ListPendingRequests(ctx context.Context) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listPendingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequests = `-- name: ListRequests :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests ORDER BY created_at DESC
`

func (q *Queries) ListRequests(ctx context.Context) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByMediaID = `-- name: ListRequestsByMediaID :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE media_id = ? AND media_type = ?
ORDER BY created_at DESC
`

type ListRequestsByMediaIDParams struct {
	MediaID   sql.NullInt64 `json:"media_id"`
	MediaType string        `json:"media_type"`
}

func (q *Queries) ListRequestsByMediaID(ctx context.Context, arg ListRequestsByMediaIDParams) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByMediaID, arg.MediaID, arg.MediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByMediaIDAndSeason = `-- name: ListRequestsByMediaIDAndSeason :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE media_id = ? AND media_type = ? AND season_number = ?
ORDER BY created_at DESC
`

type ListRequestsByMediaIDAndSeasonParams struct {
	MediaID      sql.NullInt64 `json:"media_id"`
	MediaType    string        `json:"media_type"`
	SeasonNumber sql.NullInt64 `json:"season_number"`
}

func (q *Queries) ListRequestsByMediaIDAndSeason(ctx context.Context, arg ListRequestsByMediaIDAndSeasonParams) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByMediaIDAndSeason, arg.MediaID, arg.MediaType, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByMediaType = `-- name: ListRequestsByMediaType :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE media_type = ?
ORDER BY created_at DESC
`

func (q *Queries) ListRequestsByMediaType(ctx context.Context, mediaType string) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByMediaType, mediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByStatus = `-- name: ListRequestsByStatus :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListRequestsByStatus(ctx context.Context, status string) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByUser = `-- name: ListRequestsByUser :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListRequestsByUser(ctx context.Context, userID int64) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByUserAndStatus = `-- name: ListRequestsByUserAndStatus :many
SELECT id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at FROM requests
WHERE user_id = ? AND status = ?
ORDER BY created_at DESC
`

type ListRequestsByUserAndStatusParams struct {
	UserID int64  `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) ListRequestsByUserAndStatus(ctx context.Context, arg ListRequestsByUserAndStatusParams) ([]*Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsByUserAndStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MediaType,
			&i.TmdbID,
			&i.TvdbID,
			&i.Title,
			&i.Year,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Status,
			&i.MonitorType,
			&i.DeniedReason,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.MediaID,
			&i.TargetSlotID,
			&i.PosterUrl,
			&i.RequestedSeasons,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestStatus = `-- name: UpdateRequestStatus :one
UPDATE requests SET
    status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, media_type, tmdb_id, tvdb_id, title, year, season_number, episode_number, status, monitor_type, denied_reason, approved_at, approved_by, media_id, target_slot_id, poster_url, requested_seasons, created_at, updated_at
`

type UpdateRequestStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) (*Request, error) {
	row := q.db.QueryRowContext(ctx, updateRequestStatus, arg.Status, arg.ID)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MediaType,
		&i.TmdbID,
		&i.TvdbID,
		&i.Title,
		&i.Year,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Status,
		&i.MonitorType,
		&i.DeniedReason,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.MediaID,
		&i.TargetSlotID,
		&i.PosterUrl,
		&i.RequestedSeasons,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
