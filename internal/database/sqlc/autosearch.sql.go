// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: autosearch.sql

package sqlc

import (
	"context"
	"database/sql"
)

const clearAllAutosearchStatus = `-- name: ClearAllAutosearchStatus :exec
DELETE FROM autosearch_status
`

func (q *Queries) ClearAllAutosearchStatus(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearAllAutosearchStatus)
	return err
}

const countItemsExceedingBackoffThreshold = `-- name: CountItemsExceedingBackoffThreshold :one
SELECT COUNT(*) FROM autosearch_status WHERE failure_count >= ?
`

func (q *Queries) CountItemsExceedingBackoffThreshold(ctx context.Context, failureCount int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countItemsExceedingBackoffThreshold, failureCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAutosearchStatus = `-- name: DeleteAutosearchStatus :exec
DELETE FROM autosearch_status WHERE item_type = ? AND item_id = ?
`

type DeleteAutosearchStatusParams struct {
	ItemType string `json:"item_type"`
	ItemID   int64  `json:"item_id"`
}

func (q *Queries) DeleteAutosearchStatus(ctx context.Context, arg DeleteAutosearchStatusParams) error {
	_, err := q.db.ExecContext(ctx, deleteAutosearchStatus, arg.ItemType, arg.ItemID)
	return err
}

const getAutosearchStatus = `-- name: GetAutosearchStatus :one

SELECT id, item_type, item_id, failure_count, last_searched_at, last_meta_change_at FROM autosearch_status WHERE item_type = ? AND item_id = ? LIMIT 1
`

type GetAutosearchStatusParams struct {
	ItemType string `json:"item_type"`
	ItemID   int64  `json:"item_id"`
}

// Autosearch status queries for tracking search failures and backoff
func (q *Queries) GetAutosearchStatus(ctx context.Context, arg GetAutosearchStatusParams) (*AutosearchStatus, error) {
	row := q.db.QueryRowContext(ctx, getAutosearchStatus, arg.ItemType, arg.ItemID)
	var i AutosearchStatus
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.FailureCount,
		&i.LastSearchedAt,
		&i.LastMetaChangeAt,
	)
	return &i, err
}

const incrementAutosearchFailure = `-- name: IncrementAutosearchFailure :exec
INSERT INTO autosearch_status (item_type, item_id, failure_count, last_searched_at)
VALUES (?, ?, 1, CURRENT_TIMESTAMP)
ON CONFLICT(item_type, item_id) DO UPDATE SET
    failure_count = autosearch_status.failure_count + 1,
    last_searched_at = CURRENT_TIMESTAMP
`

type IncrementAutosearchFailureParams struct {
	ItemType string `json:"item_type"`
	ItemID   int64  `json:"item_id"`
}

func (q *Queries) IncrementAutosearchFailure(ctx context.Context, arg IncrementAutosearchFailureParams) error {
	_, err := q.db.ExecContext(ctx, incrementAutosearchFailure, arg.ItemType, arg.ItemID)
	return err
}

const listItemsExceedingBackoffThreshold = `-- name: ListItemsExceedingBackoffThreshold :many
SELECT id, item_type, item_id, failure_count, last_searched_at, last_meta_change_at FROM autosearch_status
WHERE failure_count >= ?
ORDER BY last_searched_at DESC
`

func (q *Queries) ListItemsExceedingBackoffThreshold(ctx context.Context, failureCount int64) ([]*AutosearchStatus, error) {
	rows, err := q.db.QueryContext(ctx, listItemsExceedingBackoffThreshold, failureCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AutosearchStatus{}
	for rows.Next() {
		var i AutosearchStatus
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ItemID,
			&i.FailureCount,
			&i.LastSearchedAt,
			&i.LastMetaChangeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAutosearchSearched = `-- name: MarkAutosearchSearched :exec
UPDATE autosearch_status
SET last_searched_at = CURRENT_TIMESTAMP
WHERE item_type = ? AND item_id = ?
`

type MarkAutosearchSearchedParams struct {
	ItemType string `json:"item_type"`
	ItemID   int64  `json:"item_id"`
}

func (q *Queries) MarkAutosearchSearched(ctx context.Context, arg MarkAutosearchSearchedParams) error {
	_, err := q.db.ExecContext(ctx, markAutosearchSearched, arg.ItemType, arg.ItemID)
	return err
}

const resetAutosearchFailure = `-- name: ResetAutosearchFailure :exec
UPDATE autosearch_status
SET failure_count = 0, last_meta_change_at = CURRENT_TIMESTAMP
WHERE item_type = ? AND item_id = ?
`

type ResetAutosearchFailureParams struct {
	ItemType string `json:"item_type"`
	ItemID   int64  `json:"item_id"`
}

func (q *Queries) ResetAutosearchFailure(ctx context.Context, arg ResetAutosearchFailureParams) error {
	_, err := q.db.ExecContext(ctx, resetAutosearchFailure, arg.ItemType, arg.ItemID)
	return err
}

const upsertAutosearchStatus = `-- name: UpsertAutosearchStatus :one
INSERT INTO autosearch_status (item_type, item_id, failure_count, last_searched_at, last_meta_change_at)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(item_type, item_id) DO UPDATE SET
    failure_count = excluded.failure_count,
    last_searched_at = excluded.last_searched_at,
    last_meta_change_at = COALESCE(excluded.last_meta_change_at, autosearch_status.last_meta_change_at)
RETURNING id, item_type, item_id, failure_count, last_searched_at, last_meta_change_at
`

type UpsertAutosearchStatusParams struct {
	ItemType         string       `json:"item_type"`
	ItemID           int64        `json:"item_id"`
	FailureCount     int64        `json:"failure_count"`
	LastSearchedAt   sql.NullTime `json:"last_searched_at"`
	LastMetaChangeAt sql.NullTime `json:"last_meta_change_at"`
}

func (q *Queries) UpsertAutosearchStatus(ctx context.Context, arg UpsertAutosearchStatusParams) (*AutosearchStatus, error) {
	row := q.db.QueryRowContext(ctx, upsertAutosearchStatus,
		arg.ItemType,
		arg.ItemID,
		arg.FailureCount,
		arg.LastSearchedAt,
		arg.LastMetaChangeAt,
	)
	var i AutosearchStatus
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ItemID,
		&i.FailureCount,
		&i.LastSearchedAt,
		&i.LastMetaChangeAt,
	)
	return &i, err
}
